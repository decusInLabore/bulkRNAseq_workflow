---
output: 
    html_document:
        code_folding: hide
        df_print: tibble
        highlight: default
        theme: paper
        toc: true
        toc_depth: 5
        toc_float: true
        css: src/assets/style/style.css

always_allow_html: yes


---

```{r setup, include=FALSE}
knitr::opts_chunk$set(
    tidy = F,
    tidy.opts = list(width.cutoff = 120),
    message = FALSE,
    warning = FALSE
)

# R to use
# module purge;source /camp/stp/babs/working/software/modulepath_new_software_tree_2018-08-13;module load pandoc/2.2.3.2-foss-2016b;ml R/4.0.3-foss-2020a

if (!require("remotes")){
  install.packages("remotes")
}

remotes::install_github("rstudio/renv")

if (!file.exists("renv.lock")){
    renv::init()
} else {
    renv::restore(prompt=FALSE)
}

renv::install("decusinlabore/biologicSeqTools2")

workdir <- getwd()
figureCount <- 1
tableCount <- 1
upload.to.database <- TRUE

```

# Create Input files

```{r, echo=T, eval=TRUE, warning=FALSE, results="asis"}

###############################################################################
###############################################################################
## Section 2: Assemble/check relevant files                                  ##
###############################################################################
###############################################################################

###############################################################################
## Option: create design file for Crick experiment                           ##
## Requirement: sample.ids.txt file with columns sampleID, sample.id

if (dir.exists("/Volumes/babs/working/boeings/")){
    hpc.mount <- "/Volumes/babs/working/boeings/"
} else if (dir.exists("Y:/working/boeings/")){
    hpc.mount <- "Y:/working/boeings/"
} else if (dir.exists("/camp/stp/babs/working/boeings/")){
    hpc.mount <- "/camp/stp/babs/working/boeings/"
} else {
    hpc.mount <- ""
}



###############################################################################
## Create a design file                                                      ##

# The easiest is create a basedesign file with the following columns:
# |sample.id|sample.group|dataseries|comp_1|comp_2|...|comp_N|LRT_Treatment|LRT_...|
# |f_experimental_factor_1|f_experimental_factor_2|...
# dataseries_colors may be specified in a dataseries_color column with a unique
# hex code (#FF0000) for each dataseries

# sample.group_colors may be specified in a sample.group_color column with one entry per 
# sample.group

# Load design file from file:

baseDesignFN <- paste0(
  pipelineList[["folder"]],
  "workdir/bulkRNAseq_workflow/design/base.design.txt"
)



dfDesign <- read.delim(
    baseDesignFN,
    header = T,
    sep = "\t",
    stringsAsFactors = F
)

## For the option below to work, the sample names need to follow the convention
# dataseries_saplegroup_replicate

## The function below requires the sampleID to be in the format:
# [dataseries]_[sampleGroup]_[replicate]
dfDesign <- biologicSeqTools2::completeDesignBasedOnSampleID(dfDesign)

#dfDesign[["f_replicate"]] <- paste0("R", sapply(dfDesign$sample.id, function(x) unlist(strsplit(x, "_"))[3]))

## Check: Make sure the above required columns are present:
names(dfDesign)

## add additional columns
# The function below requires a sample name structure of 
# dataseries, sampleGroup, replicate. 
# There should be no underscores, but the two in the above example. 
# dfDesign <- biologicSeqTools2::completeDesignBasedOnSampleID(dfBaseDesign)

## Make sure colors are specified
dfDesign$sample.groups <- NULL

###############################################################################
## Add dataseries color, if not provided in base design file                 ##
pos <- grep("^dataseries_color$", names(dfDesign))
        
if (length(pos) == 0){
    dataseries <- unique(dfDesign$dataseries)
    dataseries_color <- dataseries


            #library(scales)
    #dataseries_color = scales::hue_pal()(length(dataseries_color))
    
    ## Avoid clashes with sample.group colors ##
     dataseries_color <- rainbow(length(dataseries_color))
    
            #sample.group_color = c("#990000", "#009900")

    dfSeriesColors <- unique(data.frame(dataseries, dataseries_color))

    dfDesign <- merge(dfDesign, dfSeriesColors, by.x = "dataseries", "dataseries")

}


## Done                                                                      ##
###############################################################################

###############################################################################
## Add sample group colors if not provied                                    ##
pos <- grep("sample.group_color", names(dfDesign))
        
if (length(pos) == 0){
    sample.group <- unique(dfDesign$sample.group)
    sample.group_color <- sample.group


            #library(scales)
    sample.group_color = scales::hue_pal()(length(sample.group_color))
            #sample.group_color = c("#990000", "#009900")

    dfGroupColors <- unique(data.frame(sample.group, sample.group_color))

    dfDesign <- merge(dfDesign, dfGroupColors, by.x = "sample.group", "sample.group")

}

# ###############################################################################
# ## Create Design File                                                        ##
# #
# ###############################################################################
# ## Organizing FASTQ files                                                    ##
# baseMount <- gsub(
#     "boeings/",
#     "",
#     hpc.mount
# )
# 
# returnList <- biologicSeqTools2::organizeFastqFiles(
#     baseMount = baseMount,
#     pathToSeqStorageFolder = pipelineList$pathToSeqStorageFolder,
#     fastqOutputDir = pipelineList$fastqDir,
#     localWorkDir = pipelineList$localWorkDir,
#     checkFileExists = FALSE
# )
# 
# shellscriptVec <- returnList$shellscriptVec
# concatenationRequired <- returnList$concatenationRequired
# 
# # Obio <- biologicSeqTools2::add2vec(
# #      obj = Obio,
# #      slot_name = "scriptVec",
# #      value = shellscriptVec
# # )
# #
# # ## Done organizing FASTQ files                                               ##
# # ###############################################################################
# #
# #
# #
# # ###############################################################################
# # ## Assemble design file                                                      ##
# #
# if (concatenationRequired){
#     print("Concatenation script executed?")
#     pathToSeqStorageFolder <- pipelineList$fastqDir
# } else {
#     pathToSeqStorageFolder <- pipelineList$pathToSeqStorageFolder
# }
# 
# 
# #################################################################################
# ## If concatenation required, generate new input files                         ##
# if (concatenationRequired){
#     system("concat.file.name")
# }
# 
# ## Done                                                                        ##
# #################################################################################
# 
# # ###############################################################################
# # ## Create Design File                                                        ##
# #
# dfDesign2 <- biologicSeqTools2::createDesignFileCrickASFsamples(
#     pathToSeqStorageFolder = pathToSeqStorageFolder,
#     FNsampleAnnotation = paste0(
#          pipelineList$localWorkDir,
#         "sample.ids.txt"
#     ),
#     paired.end = pipelineList$paired.end,
#     baseMount = baseMount,
#     fastqDir = pipelineList$fastqDir
# 
# )
# 
# dfDesign2 <- dfDesign2[dfDesign2$NGS != "",]
# 
# dfDesign2 <- unique(dfDesign2[,c("sample.id", "original.NGS", "NGS" )]) 
# dfDesign2 <- dfDesign2[dfDesign2$sample.id %in% dfDesign$sample.id, ]
# 
# dfDesign$NGS <- NULL
# dfDesign$original.NGS <- NULL
# 
# dfDesign <- merge(
#     dfDesign,
#     dfDesign2,
#     by.x = "sample.id",
#     by.y = "sample.id"
# )
# 
# 
# write.table(
#     dfDesign,
#     pipelineList[["designFN"]] , 
#     sep = "\t",
#     row.names = F
# )
##                                                                           ##
###############################################################################

###############################################################################
## Order dfDesign for displays.                                              ##


## Done with colors
##
###############################################################################

###############################################################################
## Create external DEseq2 folder                                             ##

## External DEseq2 results can be saved in the /data/DEseq2external folder
# pipelineList[["dataDir"]]
#     
# if (!dir.exists(paste0(pipelineList[["dataDir"]], "DEseq2External"))){
#     dir.create(paste0(pipelineList[["dataDir"]], "DEseq2External"), recursive = T)
# }

## External DEseq2 results can be res(dds) and saved with write.table ##



## Done                                                                      ##
###############################################################################

###############################################################################
## If applicable - add external input files                                  ##

## Each DESeq2 comparison should be saved in a separate text file containing 
## the DESeq2::res(dds) output for that comparison. It should be saved in the 
## data/DEseq2External folder

## Done adding external                                                      ##
###############################################################################

## Save design file for the workflow in PartB ##

## Additon for backwards compatibility - to be phased out. 
dfDesign[["FASTQ"]] <- dfDesign$sample.id

write.table(
    dfDesign,
    pipelineList[["designFN"]] , 
    sep = "\t",
    row.names = F
)

## check design file ##
## This section will check if all relevant columns are present

# sample.id has a unique name for each sample without spaces, 
# e.g. dataseries_sampleGroup_rep1

## sample.group summarises sample.ids of the same sample group, 
# e.g. dataseries_sampleGroup

## dataseries
# supergroup. E.g. Treatment over various timepoints or a cell line

## comp_1 to comp_N-
# comp_1 to comp_N specify differential gene expression comparisons. In each column
# samples are assigned to group_A or group_B prefixed with a 1_ or 2_ depending on the 
# position in the A vs B differential gene expression comparison.

## LRT_....
# Saple groups for a LRT comparison. Assign each sample to an LRT group or leave 
# empty if that sample is not to be included into that LRT. 

## timeseries
# if you have a time-series experiment, indicate a timepoint for each sample. 

## f_
# indicate experimental factors in the experiment. Prefix each variable factor
# with an f_

## Keep in mind that all entries in the DESeq2 models need to be present as columns


## Done design file                                                          ##
###############################################################################

###############################################################################
## Create model files                                                        ##

# If you already have a model file, just add the path to the file at the bottom
# of this section. In this case, there is no need to create the file using this
# template.

comparisonID <- c(
    names(dfDesign)[grep("comp_", names(dfDesign))]
)
comparison <- rep("", length(comparisonID))
for (i in 1:length(comparisonID)){
    contrasts = sort(as.vector(unique(dfDesign[,comparisonID[i]])), decreasing = FALSE)
    contrasts = contrasts[contrasts != ""]

    contrasts <- gsub("^1_", "", contrasts)
    contrasts <- gsub("^2_", "", contrasts)

    #Create contrast vector
    #contrast.vector = c([condition],[1_diff.gene set, e.g. mt],[2_baseline, e.g. wt])
    #if (contrasts[2] != "scr"){
    #  contrasts = rev(contrasts)
    #}
    
    if (length(contrasts) > 0){
        sel.col = contrasts

        contrast.vector = append("condition", contrasts)
        colName = paste(contrasts, collapse = "_vs_")
        comparison[i] <- colName  
    } else {
        comparison[i] <- gsub("comp_", "", comparisonID[i])
    }
    
}

test <- rep("Wald", length(comparison))
type <- rep("DGE", length(comparison))

model <- rep("~ condition", length(comparison))

## You might need to replace the above model vector with a bespoke model
# for each comparison
# example for an experiment with 5 comparisons
# model <- c(
#     "~ condition",
#     "~ condition + f_timepoint + condition:f_timepoint",
#     "~ condition + f_timepoint + condition:f_timepoint",
#     "~ condition + f_timepoint + condition:f_timepoint",
#     "~ condition + f_timepoint + condition:f_timepoint"
# )

## Reduced model not relevant for a DGE, but a column that needs to be present
reducedModel <- rep("", length(comparison))

## Normalise all samples together, or just those involved in the DGE comparison
normalizeAllSamplesTogether <- rep(FALSE, length(comparison))
betaPrior <- rep(TRUE, length(comparison))


dfModel <- data.frame(
    comparison,
    comparisonID,
    test,
    type,
    model,
    reducedModel,
    normalizeAllSamplesTogether,
    betaPrior, stringsAsFactors = TRUE
)


## Now add the LRT part
comparisonID <- names(dfDesign)[grep("LRT_", names(dfDesign))]
comparison <- names(dfDesign)[grep("LRT_", names(dfDesign))]

## Use conditon as stand-in for the variable to do LRT on. 

if (length(comparison) > 0){
        test <- rep("LRT", length(comparison))
        type <- rep("LRT", length(comparison))
        model <- rep("~ condition", length(comparison))
        reducedModel <- rep("~1", length(comparison))
        normalizeAllSamplesTogether <- rep(FALSE, length(comparison))
        betaPrior <- rep("", length(comparison))



        dfMLRT <- data.frame(
            comparison,
            comparisonID,
            test,
            type,
            model,
            reducedModel,
            normalizeAllSamplesTogether,
            betaPrior,
            stringsAsFactors = FALSE
        )

        dfModel <- rbind(
            dfModel,
            dfMLRT
        )
}

dfModel[is.na(dfModel)] <- ""


write.table(dfModel ,pipelineList[["modelFN"]] , row.names = FALSE, sep = "\t")

## Here model is loaded from file
 
#model.file <- "design/dge.model.table.txt"

file.exists(pipelineList[["modelFN"]])

## Write model to file

## Done model file                                                           ##
###############################################################################


###############################################################################
## Create NF-core samplesheet file                                           ##
## Instructions: https://nf-co.re/rnaseq/usage
## sample,fastq_1,fastq_2, strandedness
# Column 	Description
# sample 	Custom sample name. This entry will be identical for multiple sequencing libraries/runs from the same sample. Spaces in sample names are automatically converted to underscores (_).
# fastq_1 	Full path to FastQ file for Illumina short reads 1. File has to be gzipped and have the extension ".fastq.gz" or ".fq.gz".
# fastq_2 	Full path to FastQ file for Illumina short reads 2. File has to be gzipped and have the extension ".fastq.gz" or ".fq.gz".
# strandedness 	Sample strand-specificity. Must be one of unstranded, forward or reverse.

## Get strandedness setting
if (pipelineList[["stranded"]]){
    strandedness <- "reverse"
} else {
    strandedness <- "unstranded"
}

if (! is.null(pipelineList[["NFcoreSettingsFN"]]) | !is.null(pipelineList[["pathToSeqStorageFolder"]])){
    
        fileNames <- as.vector(unlist(sapply(pipelineList$pathToSeqStorageFolder, function(x) paste0(x, list.files(x)))))
        files <- as.vector(unlist(sapply(pipelineList$pathToSeqStorageFolder, function(x) list.files(x))))
        sampleIDs <- sapply(
                    files, 
                    function(x)
                      unlist(
                        strsplit(
                            x,
                            "_"
                        )
                      )[1]
        )
        
        dfTemp <- data.frame(
            fileNames, 
            files, 
            sampleIDs
        )
        
        dfTemp2 <- unique(dfDesign[,c("sampleID", "sample.id")])
        dfTemp2 <- dfTemp2[dfTemp2$sampleID %in% dfTemp$sampleIDs, ]
        dfTemp <- merge(
            dfTemp, 
            dfTemp2, 
            by.x = "sampleIDs",
            by.y = "sampleID"
        )
        
        dfTemp[["base"]] <- dfTemp$files
        dfTemp[grep("_R1_", dfTemp$files), "base"] <-  sapply(as.vector( dfTemp[grep("_R1_", dfTemp$files), "base"]), function(x) unlist(strsplit(x, "_R1_"))[1])
        dfTemp[grep("_R2_", dfTemp$files), "base"] <-  sapply(as.vector( dfTemp[grep("_R2_", dfTemp$files), "base"]), function(x) unlist(strsplit(x, "_R2_"))[1])
        
        if (pipelineList[["paired.end"]]){
            dfR1 <- dfTemp[grep("_R1_", dfTemp$files),]
            dfR2 <- dfTemp[grep("_R2_", dfTemp$files),]
            
            dfR1 <- dfR1[dfR1$base %in% dfR2$base, ]
            dfR2 <- dfR2[dfR2$base %in% dfR1$base, ]
            
            ## Order ##
            for (i in 1:nrow(dfR1)){
                sample <- dfR1[i, "sample.id"]
                fastq_1 <- dfR1[i, "fileNames"]
                
                ## Find fastq 2
                baseID <- dfR1[i, "base"]
                
                pos <- grep(paste0("^",baseID,"$"), dfR2$base)
                fastq_2 <- dfR2[pos, "fileNames"]
                
                
                newRow <- data.frame(sample, fastq_1, fastq_2, strandedness)
                
                if (i==1){
                    dfRes <- newRow
                } else {
                    dfRes <- rbind(
                        dfRes, 
                        newRow
                    )
                }
            }
            
            dfRes <- dfRes[order(dfRes$sample), ]
            
            ## Save nextflow sample sheet ##
            write.csv(
                dfRes, 
                pipelineList$NFcoreSettingsFN,
                row.names = FALSE,
                quote=FALSE
            )
            
        } else {
            ## Single end nextflow sample sheet ##
            dfR1 <- dfTemp[grep("_R1_", dfTemp$files),]
            
            ## Order ##
            for (i in 1:nrow(dfR1)){
                sample <- dfR1[i, "sample.id"]
                fastq_1 <- dfR1[i, "fileNames"]
                
                fastq_2 <- ""
                
                
                newRow <- data.frame(sample, fastq_1, fastq_2, strandedness)
                
                if (i==1){
                    dfRes <- newRow
                } else {
                    dfRes <- rbind(
                        dfRes, 
                        newRow
                    )
                }
            }
            
            
            
            
        }
       
        ## Save nextflow sample sheet ##
        dfRes <- dfRes[order(dfRes$sample), ]
        
        write.csv(
            dfRes, 
            pipelineList$NFcoreSettingsFN,
            row.names = FALSE,
            quote = FALSE
        )
    
}




## Done                                                                      ##
###############################################################################

###############################################################################
## Part 2A: Use to start from fastq files                                    ##

###############################################################################
## Create analysis scripts                                                   ##
# sDir <- getwd()
# setwd(Obio@parameterList$localWorkDir)
# 
# Obio <- biologicSeqTools2::createbulkRNASeqAnalysisBashScripts(
#     obj = Obio,
#     scriptVecSlot = "scriptVec"
# )
# setwd(sDir)

## Run analysis BASH script ##
## Done creating analysis bash scripts                                       ##
###############################################################################

## End Part 2A                                                               ##
###############################################################################

###############################################################################
## Part 2B: Start from (RSEM) read count matrix                              ##


## In this experiment a summary RSEM file needs to be created.

## RSEM genes.result files are located here:
#E07
#/camp/stp/babs/working/eastp/analysis/073_fox12-_chicken_gonads.gunes.taylor/experiments/RN20094_E07/GRCg6a/processed_data/results/star_rsem

#E10
#/camp/stp/babs/working/eastp/analysis/073_fox12-_chicken_gonads.gunes.taylor/experiments/RN20152_E10/GRCg6a/processed_data/results/star_rsem

#E14
#/camp/stp/babs/working/eastp/analysis/073_fox12-_chicken_gonads.gunes.taylor/experiments/RN21119_E14/GRCg6a/processed_data/results/star_rsem



# ## Create RSEM count matrix if it doesn't exist yet ##
# hairpinFN <- "/camp/stp/babs/working/boeings/Projects/pachnisv/franze.progatzky/475_EGC_miRNAseq_RN21203/workdir/fitht_results/edgeR/miRBase_hairpin/hairpin_counts.csv"
# 
# dfHairpin <- read.csv(hairpinFN, stringsAsFactors = F)
# names(dfHairpin) <- gsub("\\.", "_", names(dfHairpin))
# row.names(dfHairpin) <- dfHairpin$X
# dfHairpin$X <- NULL
# dfHairpin <- data.frame(t(dfHairpin))
# 
# 
# p1 <- sapply(names(dfHairpin), function(x) unlist(strsplit(x, "_"))[1])
# p2 <- sapply(names(dfHairpin), function(x) unlist(strsplit(x, "_"))[2])
# p2 <- paste0(p2, "Hairpin")
# p3 <- sapply(names(dfHairpin), function(x) unlist(strsplit(x, "_"))[3])
# p3 <- gsub(".hairpin", "", p3)
# 
# names(dfHairpin) <- paste0(p1, "_", p2, "_", p3)
# dfHairpin[["gene"]] <- row.names(dfHairpin)
# dfHairpin[["gene"]] <- gsub("_mir_", "_miR_", dfHairpin$gene)
# 
# dfCount <- dfHairpin
# 
# #dfCount  <- dplyr::full_join(dfMature,  dfHairpin, by = "gene")
# dfCount[is.na(dfCount)] <- 0
# #dfCount[dfCount$mature_miRNA == 0, "mature_miRNA"] <- dfCount[dfCount$mature_miRNA == 0, "gene"]
# 
# orderVec <- names(dfCount)
# orderVec <- orderVec[orderVec != "mature_miRNA"]
# orderVec <- orderVec[orderVec != "gene"]
# #orderVec <- c("mature_miRNA", sort(orderVec))
# 
# dfCount <- dfCount[, orderVec]

# row.names(dfCount) <- dfCount$mature_miRNA
# dfCount$mature_miRNA <- NULL

# FNcount <- "../../basedata/count.matrix.txt"
# write.table(dfCount, FNcount,  sep="\t")
# 
# 
# if (!is.null(pipelineList[["pathToRSEMresultsFiles"]] )){
#     files <- unlist(
#         lapply(
#             pipelineList[["pathToRSEMresultsFiles"]], 
#             function(x)paste0(x, list.files(x))
#         )
#     )
# }
# 
# files <- files[grep(".genes.results", files)]
# 
# 
# 
# files = paste(
#     files,
#     collapse = " "
# )
# 
# RSEM.CMD = paste(
#     "module load RSEM/1.3.3-foss-2021a;",
#     "rsem-generate-data-matrix ",
#     files,
#     " > ",
#     pipelineList[["preProcessedCountTableFN"]],
#     sep=""
# )
# 
# ## Run RSEM command
# ## The above command might only work on the command line
# sink("../RSEM.command.sh")
# cat(RSEM.CMD)
# sink()

#system(RSEM.CMD)
## Run RSEM shell script ##

# hairpinFN <- "/camp/stp/babs/working/boeings/Projects/pachnisv/franze.progatzky/475_EGC_miRNAseq_RN21203/workdir/fitht_results/edgeR/miRBase_hairpin/hairpin_counts.csv"
# 
# dfHairpin <- read.csv(hairpinFN, stringsAsFactors = F)
# names(dfHairpin) <- gsub("\\.", "_", names(dfHairpin))
# row.names(dfHairpin) <- dfHairpin$X
# dfHairpin$X <- NULL
# dfHairpin <- data.frame(t(dfHairpin))
# 
# 
# p1 <- sapply(names(dfHairpin), function(x) unlist(strsplit(x, "_"))[1])
# p2 <- sapply(names(dfHairpin), function(x) unlist(strsplit(x, "_"))[2])
# p2 <- paste0(p2, "Hairpin")
# p3 <- sapply(names(dfHairpin), function(x) unlist(strsplit(x, "_"))[3])
# p3 <- gsub(".hairpin", "", p3)
# 
# names(dfHairpin) <- paste0(p1, "_", p2, "_", p3)
# dfHairpin[["gene"]] <- row.names(dfHairpin)
# dfHairpin[["gene"]] <- gsub("_mir_", "_miR_", dfHairpin$gene)
# 
# dfCount  <- dplyr::full_join(dfMature,  dfHairpin, by = "gene")
# dfCount[is.na(dfCount)] <- 0
# dfCount[dfCount$mature_miRNA == 0, "mature_miRNA"] <- dfCount[dfCount$mature_miRNA == 0, "gene"]
# 
# orderVec <- names(dfCount)
# orderVec <- orderVec[orderVec != "mature_miRNA"]
# orderVec <- orderVec[orderVec != "gene"]
# orderVec <- c("mature_miRNA", sort(orderVec))
# 
# dfCount <- dfCount[, orderVec]
# 
# row.names(dfCount) <- dfCount$mature_miRNA
# dfCount$mature_miRNA <- NULL
# 
# FNcount <- "../../basedata/count.matrix.txt"
# write.table(dfCount, FNcount,  sep="\t")
# 
# ## Read resulting RSEM table
# dfRSEM <- read.delim(
#     pipelineList[["preProcessedCountTableFN"]], 
#     sep = "\t",
#     header = T,
#     stringsAsFactors = F
# )

## Make sure it's integers:
# dfRSEM[,2:ncol(dfRSEM)] <- round(dfRSEM[,2:ncol(dfRSEM)])
# 
# for (i in 1:length(pipelineList[["pathToRSEMresultsFiles"]])){
#     names(dfRSEM) <- gsub(paste0("X", gsub("-", ".", gsub("/", ".", pipelineList[["pathToRSEMresultsFiles"]][[i]]))), "", names(dfRSEM))
# }
# 
# names(dfRSEM) <- gsub(".genes.results", "", names(dfRSEM))
# 
# ## now change sampleIDs to sample.ids
# 
# dfTranslate <- unique(dfDesign[,c("sampleID", "sample.id")])

# dfRSEM <- dfCount
# 
# samplesPresent <- names(dfRSEM)[names(dfRSEM) != "X"]
# samplesNotPresent <- dfDesign$sample.id[!(dfDesign$sample.id %in% names(dfRSEM))]
# 
# ## Updating dfDesign
# dfDesign <- dfDesign[dfDesign$sample.id %in% samplesPresent, ]
# 
# write.table(
#     dfDesign,
#     pipelineList[["designFN"]] , 
#     sep = "\t",
#     row.names = F
# )
# 
# 
# dfTranslate <- unique(dfDesign[,c("sampleID", "sample.id")])
# 
# ## Renaming RSEM columns
# rsemOrder <- c(
#         "ENSMUSG",
#         paste0(
#             as.vector(dfDesign$sample.id)
#             #"_TPM"
#         )
#     )
# 
# dfRSEM[["ENSMUSG"]] <- row.names(dfRSEM)
# 
# 
# # for (i in 1:nrow(dfTranslate)){
# #     names(dfRSEM) <- gsub(paste0("^", as.vector(dfTranslate[i,"sampleID"]), "$"), as.vector(dfTranslate[i,"sample.id"]), names(dfRSEM))
# # }
# # 
# # names(dfRSEM) <- gsub("X", "ENSGALG", names(dfRSEM))
# 
# ## Format: |gene_id column names X|sample.id[1]|sample.id[2]|sample.id[3]|...
# 
# 
#     
# dfRSEM <- dfRSEM[, rsemOrder]
#     
# 
# write.table(dfRSEM, pipelineList[["countTableFN"]], sep = "\t", row.names=F)


## Format of the RSEM read count matrix:

## TPM table ##
## Option A: Specify the folder in which the RSEM genes.result files reside

## Option B: Specify TPM file directly. The TPM file needs to have the following 
##           format: 

## End Part 2A                                                               ##
###############################################################################


###############################################################################
## The section below is only required if you haven't prepared the files      ##
## yet                                                                       ##
###############################################################################

###############################################################################
## Part 2C: I have a read-count matrix, a TPM file, and DESeq2 differential  ##
##          gene expression outputs                                          ##

## RSEM_folder
## The RSEM folder points to the folder containing the [sampleID].genes.result files
# pipelineList[["RSEM_folder"]] <- paste0(pipelineList[["folder"]], "workdir/RSEM/Ensembl/")


## TPM file ##
## The tpm file should contain the following columns:
## first column: primary gene alignment ID, named either "X" or "ENSG|ENSMUSG|or whatever species
## second to N-th column: one column for each sample as liste in Obio@dfDesign$sample.id. Can be extended by a
## _TPM suffix. 



if (!is.null(pipelineList[["pathToRSEMresultsFiles"]] )){
    files <- unlist(
        lapply(
            pipelineList[["pathToRSEMresultsFiles"]],
            function(x)paste0(x, list.files(x))
        )
    )
}


files <- files[grep(".genes.results", files)]

samples <- sapply(
    files,
    function(x)
    strsplit(x, "/")
)

    samples <- unlist(sapply(
        samples,
        function(x)
        x[length(x)]
    ))

    samples <- as.vector(gsub(".genes.results", "", samples))

    dfTables <- biologicSeqTools2::create.tpm.and.fpkm.tables(
        files = files,
        samples = samples
    )

    dfTPM <- dfTables$df.tpm

    ## Exchange names ##
    dfTranslate <- unique(dfDesign[,c("sampleID", "sample.id")])

    ## Renaming RSEM columns
    for (i in 1:nrow(dfTranslate)){
        names(dfTPM) <- gsub(paste0("^", as.vector(dfTranslate[i,"sampleID"]), "_TPM"), paste0(as.vector(dfTranslate[i,"sample.id"]),"_TPM"), names(dfTPM))
    }

    # Order dfTPM according design file ##
    tpmOrder <- c(
        "gene_id",
        paste0(
            as.vector(dfDesign$sample.id),
            "_TPM"
        )
    )

#dfTPM <- dfRSEM
names(dfTPM) <- gsub("ENSMUSG", "gene_id", names(dfTPM))
names(dfTPM) <- gsub("_TPM", "", names(dfTPM))

###############################################################################
## Add NF-core TPM table                                                     ##
dfTPM <- read.delim(
    pipelineList[["preProcessedTPMTableFN"]], 
    sep="\t",
    stringsAsFactors=F
)

## Translate sampleID names to gene id names ##
dfTranslate <- unique(dfDesign[,c("sampleID", "sample.id")])

## Renaming TPM columns
for (i in 1:nrow(dfTranslate)){
    names(dfTPM) <- gsub(paste0("^", as.vector(dfTranslate[i,"sampleID"]), "_TPM"), paste0(as.vector(dfTranslate[i,"sample.id"]),"_TPM"), names(dfTPM))
}
    
# Select relevant columns and order dfTPM according design file ##
tpmOrder <- c(
    "gene_id",
    paste0(
        as.vector(dfDesign$sample.id)
    )
)

dfTPM <- unique(dfTPM[, tpmOrder])

write.table(
    dfTPM,
    pipelineList[["TpmTableFN"]],
    sep = "\t",
    row.names = F
)


###############################################################################
## Add NF-core RSEM count table                                              ##
dfRSEM <- read.delim(
    pipelineList$preProcessedCountTableFN, 
    sep="\t",
    stringsAsFactors=F
)

## Translate sampleID names to gene id names ##
dfTranslate <- unique(dfDesign[,c("sampleID", "sample.id")])

## Renaming TPM columns
for (i in 1:nrow(dfTranslate)){
    names(dfRSEM) <- gsub(paste0("^", as.vector(dfTranslate[i,"sampleID"])), paste0(as.vector(dfTranslate[i,"sample.id"])), names(dfRSEM))
}
    
# Select relevant columns and order dfTPM according design file ##
rsemOrder <- c(
    "gene_id",
    paste0(
        as.vector(dfDesign$sample.id)
    )
)

dfRSEM <- unique(dfRSEM[, rsemOrder])

write.table(
    dfRSEM,
    pipelineList[["countTableFN"]],
    sep = "\t",
    row.names = F
)






## End Part 2C                                                               ##
###############################################################################




```  