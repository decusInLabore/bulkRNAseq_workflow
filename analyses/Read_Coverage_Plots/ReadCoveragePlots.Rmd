---
title: "Bulk RNA-Seq Read Coverage Plot Module"
author: "Stefan Boeing stefan.boeing@crick.ac.uk"
date: 'Compiled: `r format(Sys.Date(), "%B %d, %Y")`'
output: 
    html_document:
        code_folding: hide
        df_print: tibble
        toc: true
        toc_depth: 5
        toc_float: true
        css:

always_allow_html: yes

---

```{css setup_css, echo=FALSE}


.table{
  width:auto;
  font-size: 10px;
}

```

```{bash setup, eval = F, include=FALSE}
###############################################################################
## Recommended R-version                                                     ##

# old, but used for this project :
module purge;source /nemo/stp/babs/working/software/modulepath_new_software_tree_2018-08-13;module load pandoc/2.2.3.2-foss-2016b;ml R/4.0.3-foss-2020a;R

# New > future
# module load R/4.3.2-gfbf-2023a

ml Singularity/3.6.4

## --cleanenv is optional. It prevents the transfer of host system environmental variables into the singularity container.

singularity shell --cleanenv --bind  /nemo:/nemo,/camp:/camp  /flask/apps/containers/all-singularity-images/r431.ubuntu.22.04.sif;

R

## Done                                                                      ##
###############################################################################


```
```{r setupr, include=FALSE}


###############################################################################
## Set the environment                                                       ##

# if (!require("remotes")){
#   install.packages("remotes")
# }
# 
# remotes::install_github("rstudio/renv")



if (!file.exists("renv.lock")){
    renv::init()
} else {
    renv::restore(prompt=FALSE)
}

#renv::install("decusinlabore/biologicSeqTools2)
#renv::install("bioc::ensembldb")
#renv::install("bioc::DESeq2")
#renv::install("bioc::clusterProfiler")
#renv

## Done                                                                      ##
###############################################################################


###############################################################################
## Set knitr options                                                         ##

knitr::opts_chunk$set(
    tidy = F,
    tidy.opts = list(width.cutoff = 120),
    message = FALSE,
    warning = FALSE
)

##                                                                           ##
###############################################################################

###############################################################################
## Set global variables                                                      ##

projectDir <- paste0(unlist(strsplit(getwd(), "scripts"))[1])
workdir <- paste0(projectDir, "workdir/")
dataDir <- paste0(projectDir, "data/")



figureCount <- 1
tableCount <- 1
upload.results.to.database <- TRUE
shinyBaseServerURL <- "shiny-bioinformatics.crick.ac.uk"

## Done                                                                      ##
###############################################################################


###############################################################################
## Load biologic object from part A                                          ##
source("load.biologic.robj.R")
# library(biologicSeqTools2)
#
# biologicDir <- paste0(dataDir, "biologic_active_object/")
#
# FN <- paste0(biologicDir,list.files(biologicDir)[grep("bioLOGIC.Robj", list.files(biologicDir))])
# load(FN)
## Done                                                                      ##
###############################################################################

```

```{r set_directories, eval=T}
## Setup plot collection object
library(knitr)
library(ggplot2)
#library(ggpubr)
#library(DT)


geneCoveragePlotVec <- c(
        "SFPQ",
        "FUS",
        "OGT",
        "PTBP2",
        "HNRNPDL",
        "DDX39A",
        "TUSC3",
        "RBM25",
        "NNAT",
        "VCP",
        #"HNRNPH1",
        "UPF1"
)


figureCount <- 1
chnkVec <- as.vector(NULL, mode = "character")

VersionPdfExt <- paste0(".V", gsub("-", "", Sys.Date()), ".pdf")

if (dir.exists("/Volumes/babs/working/boeings/")){
    hpc.mount <- "/Volumes/babs/working/boeings/"
} else if (dir.exists("Y:/working/boeings/")){
    hpc.mount <- "Y:/working/boeings/"
} else if (dir.exists("/nemo/stp/babs/working/boeings/")){
    hpc.mount <- "/nemo/stp/babs/working/boeings/"
} else {
    hpc.mount <- ""
}


# if (length(.libPaths()) > 2){
#     .libPaths(.libPaths()[2:3])
# }







## Loading the BABS password ##
if (Obio@parameterList[["upload.results.to.database"]]){
    FN <- paste0(hpc.mount, "Projects/reference_data/pwd_folder/babs.txt")
    dbTable <- read.delim(
      FN,
      header = F,
      sep = "\t",
      stringsAsFactors = F
    )
}

 Obio@dbDetailList[["db.pwd"]] <- as.vector(dbTable[1,1])


# Obio <- biologicSeqTools2::setMountingPoint(Obio)
# Obio <- biologicSeqTools2::setAnalysisPaths(Obio)
# Obio <- biologicSeqTools2::setCrickGenomeAndGeneNameTable(Obio)
# Obio <- biologicSeqTools2::createAnalysisFolders(
#     Obio #,
#     #baseDir="/nemo/stp/babs/working/boeings/Projects/",
#     #localBaseDir = paste0(hpc.mount, "Projects/")
# )
# Obio <- biologicSeqTools2::setDataBaseParameters(Obio)


# Obio@parameterList[["reportFigDir"]] <- paste0(Obio@parameterList$workdir,Obio@parameterList$project_id, "/report_figures/")
# 
# ## Create outputfolders ##
# if (!dir.exists(paste0(Obio@parameterList$workdir,Obio@parameterList$project_id))){
#     dir.create(paste0(Obio@parameterList$workdir,Obio@parameterList$project_id))
# }
# 
# if (!dir.exists(Obio@parameterList$reportFigDir)){
#     dir.create(Obio@parameterList$reportFigDir)
# }

figureCount <- 1
```

## Create Reference

```{r create_bigwig2, echo=T, eval=TRUE, warning=FALSE, result=F, warning= F, include = F}

#library(biomaRt)

species <- Obio@parameterList$species

species <- unlist(strsplit(species, "_"))
species[1] <- substr(species[1], 1, 1)
selString <- paste0(species, collapse = "") 
selString <- paste0(selString, "_gene_ensembl")

if (is.null(Obio@parameterList$release)){
    release <- 95
} else {
    release <- Obio@parameterList$release
}

releaseID <- gsub("release-", "", tolower(release))

## Lookup biomart url
lookupTable <- biomaRt::listEnsemblArchives()
lookupTable <- lookupTable[lookupTable$version  == releaseID, ]

if (nrow(lookupTable) > 0){
    biomartURL <- as.vector(lookupTable[1,"url"])
} else {
    stop("No ensembl biomart table available for this release.")
}


primaryAlignmentGeneID <- Obio@parameterList$primaryAlignmentGeneID
geneIDcolumn <- Obio@parameterList$geneIDcolumn


ensembl_mart = biomaRt::useMart("ENSEMBL_MART_ENSEMBL", host = biomartURL)

if (Obio@parameterList$species == "mus_musculus"){
    selString <- "mmusculus"
} else if (Obio@parameterList$species == "homo_sapiens") {
   selString <- "hsapiens"
} else if (Obio@parameterList$species == "gallus_gallus") {
   selString <- "ggallus"
} else{
    stop()
}


ensembl_dataset = biomaRt::useDataset(paste0(selString, "_gene_ensembl"),mart=ensembl_mart)

#print(ensembl_dataset)

selected_attributes = c("ensembl_transcript_id", "ensembl_gene_id", 
                        "external_gene_name", "strand", "chromosome_name", "start_position", "end_position", 
                        "gene_biotype", "transcript_biotype")
biomaRt::biomartCacheClear()

data = biomaRt::getBM(attributes = selected_attributes, mart = ensembl_dataset)
#head(data)

data = dplyr::rename(data, 
                     transcript_id = ensembl_transcript_id, 
                     gene_id = ensembl_gene_id, 
                     gene_name = external_gene_name)
#head(data)

temporary_file = tempfile(pattern = "file", tmpdir = tempdir(), fileext = ".rds")
saveRDS(data, temporary_file)

transcript_metadata = readRDS(temporary_file)
#head(transcript_metadata)

## Download txDB

## Create gene annotation if it is not present ##
## To be activated ##

species <- Obio@parameterList$species

species <- unlist(strsplit(species, "_"))
species[1] <- substr(species[1], 1, 1)
selString <- paste0(species, collapse = "") 
selString <- paste0(selString, "_gene_ensembl")

if (is.null(Obio@parameterList$release)){
    release <- 95
} else {
    release <- Obio@parameterList$release
}

releaseID <- gsub("release-", "", tolower(release))

## Lookup biomart url
lookupTable <- biomaRt::listEnsemblArchives()
lookupTable <- lookupTable[lookupTable$version  == releaseID, ]

if (nrow(lookupTable) > 0){
    biomartURL <- as.vector(lookupTable[1,"url"])
    biomartURL <- gsub("https:", "http:", biomartURL)
} else {
    stop("No ensembl biomart table available for this release.")
}

## Legacy version of function from: https://github.com/Bioconductor/GenomicFeatures/blob/RELEASE_3_16/R/makeTxDbFromBiomart.R
# From V3.17 onwards useEnsemblGennomes() is used instead of useEnsembl() - which doesn't have host parameter (yet)

### =========================================================================
### makeTxDbFromBiomart()
### -------------------------------------------------------------------------
###
### For people who want to tap BioMart.
### Typical use:
###   txdb <- makeTxDbFromBiomart("hsapiens_gene_ensembl")
### Speed:
###   - for biomart="ENSEMBL_MART_ENSEMBL" and dataset="hsapiens_gene_ensembl":
###       (1) download takes about 8 min.
###       (2) db creation takes about 60-65 sec.
###


### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
### Some helper functions to facilitate working with the biomaRt package.
###

.isEnsemblMirror <- function(host) {
  hostadd <- gsub("http[s]*://", "", host, ignore.case = TRUE)
  domain <- vapply(strsplit(hostadd, "\\."), `[[`, character(1L), 1L)
  ## capture known hosts
  tolower(domain) %in% c("useast", "uswest", "asia", "www", "ensembl")
}

### A thin wrapper to useEnsembl() that checks the user-supplied arguments.
.useMart2 <- function(biomart="ENSEMBL_MART_ENSEMBL",
                      dataset="hsapiens_gene_ensembl",
                      host="https://www.ensembl.org")
{
  ### Could be that the user got the 'biomart' and/or 'dataset' values
  ### programmatically via calls to listMarts() and/or listDatasets(). Note
  ### that listMarts() and listDatasets() are returning data frames where
  ### the columns are factors for the former and "AsIs" character vectors
  ### for the latter.
  if (is.factor(biomart))
          biomart <- as.character(biomart)
  if (!(S4Vectors::isSingleString(biomart) && biomart != ""))
          stop("'biomart' must be a single non-empty string")
  if (is(dataset, "AsIs"))
          dataset <- as.character(dataset)
  if (!(S4Vectors::isSingleString(dataset) && dataset != ""))
          stop("'dataset' must be a single non-empty string")
  if (!(S4Vectors::isSingleString(host) && host != ""))
          stop("'host' must be a single non-empty string")
  if (.isEnsemblMirror(host))
          biomaRt::useEnsembl(biomart = biomart, dataset = dataset, host = host)
  else
          biomaRt::useEnsembl(biomart = biomart, dataset = dataset, host = host)
}

### TODO: Share this with normalization of 'filter' arg in the transcripts(),
### exons(), cds(), and genes() extractors.
.normarg_filter <- function(filter)
{
  if (is.null(filter) || identical(filter, ""))
          return(setNames(list(), character(0)))
  if (!is.list(filter))
          stop("'filter' must be a named list")
  if (length(filter) == 0L)
          return(setNames(list(), character(0)))
  filter_names <- names(filter)
  if (is.null(filter_names))
          stop("'filter' must be a named list")
  if (any(filter_names %in% c(NA, "")))
          stop("names on 'filter' cannot be NA or the empty string")
  if (anyDuplicated(filter_names))
          stop("names on 'filter' must be unique")
  if (!all(sapply(filter, is.atomic)))
          stop("'filter' list elements must be atomic")
  if (any(sapply(filter, anyNA)))
          stop("'filter' list elements cannot contain NAs")
  filter
}

### A thin wrapper around getBM() that takes the filters in the form of a named
### list.
.getBM2 <- function(attributes, filter=NULL, ...)
{
  filter <- .normarg_filter(filter)
  if (length(filter) == 0L) {
    bm_filters <- bm_values <- ""
  } else {
    bm_filters <- names(filter)
    bm_values <- unname(filter)
    bm_values[elementNROWS(bm_values) == 0L] <- paste0(
            "____this_is_a_very_unlikely_valid_value_but_you_never_know_",
            "this_is_just_a_dirty_hack_to_work_around_getBM_",
            "misinterpretation_of_empty_list_elements_in_values____")
  }
 biomaRt::getBM(attributes, filters=bm_filters, values=bm_values, ...)
}

.normarg_id_prefix <- function(id_prefix)
{
  if (!S4Vectors::isSingleString(id_prefix))
          stop("'id_prefix' must be a single string")
  id_prefix
}

### Add filter created from user-supplied transcript_ids to user-specified
### filter.
.add_tx_id_filter <- function(filter, transcript_ids=NULL, id_prefix="ensembl_")
{
  filter <- .normarg_filter(filter)
  tx_name_colname <- paste0(id_prefix, "transcript_id")
  if (is.null(transcript_ids)) {
    if (tx_name_colname %in% names(filter))
            warning(wmsg("transcript ids should be specified via the ",
                         "'transcript_ids' rather than the 'filter' argument"))
    return(filter)
  }
  if (!is.character(transcript_ids))
          stop("'transcript_ids' must ba a character vector")
  if (any(is.na(transcript_ids)))
          stop("'transcript_ids' cannot contain NAs")
  if (tx_name_colname %in% names(filter))
          stop(wmsg("transcript ids cannot be specified via the ",
                    "'transcript_ids' and 'filter' arguments ",
                    "at the same time"))
  filter[[tx_name_colname]] <- transcript_ids
  filter
}

.getBiomartDbVersion <- function(host, biomart)
{
  marts <- biomaRt::listMarts(host = host)

  mart_rowidx <- match(biomart, marts[["biomart"]])
  ## This should never happen.
  if (is.na(mart_rowidx) || length(mart_rowidx) != 1L)
          stop("found 0 or more than 1 \"", biomart, "\" BioMart database")
  marts[mart_rowidx, "version"]
}

.get_Ensembl_release_from_db_version <- function(db_version)
{
  db_version <- tolower(db_version)
  sub("^ensembl( ((bacteria|fungi|metazoa|plants|protists) )?genes)? ([0-9]+).*$", "\\4", db_version)
}

.get_EnsemblGenomes_kingdom_from_biomart <- function(biomart)
{
  biomart <- tolower(biomart)
  if (substr(biomart, 1, 14) == "bacterial_mart")
          return("bacteria")
  if (substr(biomart, 1, 10) == "fungi_mart")
          return("fungi")
  if (substr(biomart, 1, 12) == "metazoa_mart")
          return("metazoa")
  if (substr(biomart, 1, 11) == "plants_mart")
          return("plants")
  if (substr(biomart, 1, 13) == "protists_mart")
          return("protists")
  NA
}


### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
### Download and preprocess the 'transcripts' data frame.
###

.makeBiomartTranscripts <- function(filter, mart, transcript_ids,
                                    recognized_attribs,
                                    id_prefix="ensembl_")
{
  message("Download and preprocess the 'transcripts' data frame ... ",
          appendLF=FALSE)
  bm_result <- .getBM2(recognized_attribs[['T']], filter,
                       mart=mart, bmHeader=FALSE)
  tx_name_colname <- paste0(id_prefix, "transcript_id")
  tx_name <- bm_result[[tx_name_colname]]
  if (!is.null(transcript_ids)) {
    idx <- !(transcript_ids %in% tx_name)
    if (any(idx)) {
      bad_ids <- transcript_ids[idx]
      stop(wmsg("invalid transcript ids: ",
                paste0(bad_ids, collapse=", ")))
    }
  }
  ## Those are the strictly required fields.
  transcripts0 <- data.frame(
          tx_id=integer(0),
          tx_chrom=character(0),
          tx_strand=character(0),
          tx_start=integer(0),
          tx_end=integer(0)
  )
  if (nrow(bm_result) == 0L) {
    message("OK")
    return(transcripts0)
  }
  tx_id <- seq_len(nrow(bm_result))
  ##if (any(duplicated(tx_name)))
  ##    stop(wmsg("the '",
  ##              tx_name_colname,
  ##              "'transcript_id' attribute contains duplicated values"))
  if (any(duplicated(bm_result)))
          stop(wmsg("the 'transcripts' data frame obtained from biomart ",
                    "contains duplicated rows"))
  tx_type <- as.character(bm_result$transcript_biotype)
  tx_chrom <- as.character(bm_result$chromosome_name)
  tx_strand <- ifelse(bm_result$strand == 1, "+", "-")
  tx_start <- bm_result$transcript_start
  tx_end <- bm_result$transcript_end
  transcripts <- data.frame(
          tx_id=tx_id,
          tx_name=tx_name,
          tx_type=tx_type,
          tx_chrom=tx_chrom,
          tx_strand=tx_strand,
          tx_start=tx_start,
          tx_end=tx_end
  )
  message("OK")
  transcripts
}


### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
### Download and preprocess the 'chrominfo' data frame.
###

### Returns NULL if it fails to fetch the chromosome lengths from the
### remote resource.
.makeBiomartChrominfo <- function(mart, extra_seqnames=NULL,
                                  circ_seqs=NULL, host)
{
  biomart <- biomaRt:::martBM(mart)
  dataset <- biomaRt:::martDataset(mart)
  is_ensembl_mart <- tolower(substr(biomart, 1, 7)) == "ensembl"
  kingdom <- .get_EnsemblGenomes_kingdom_from_biomart(biomart)
  if (is_ensembl_mart || !is.na(kingdom)) {
    message("Download and preprocess the 'chrominfo' data frame ... ",
            appendLF=FALSE)
    if (is_ensembl_mart) {
      if (grepl("grch37.ensembl.org", host, ignore.case = TRUE)) {
        ## Ensembl GRCh37 mart
        chromlengths <- try(fetchChromLengthsFromEnsembl(dataset,
                                                         use.grch37=TRUE,
                                                         extra_seqnames=extra_seqnames),
                            silent=TRUE)
      } else {
        ## Ensembl mart
        db_version <- .getBiomartDbVersion(host, biomart)
        ensembl_release <-
                .get_Ensembl_release_from_db_version(db_version)
        chromlengths <- try(fetchChromLengthsFromEnsembl(dataset,
                                                         release=ensembl_release,
                                                         extra_seqnames=extra_seqnames),
                            silent=TRUE)
      }
    } else {
      ## One of the EnsemblGenomes marts
      db_version <- .getBiomartDbVersion(host, biomart)
      ensembl_release <- .get_Ensembl_release_from_db_version(db_version)
      chromlengths <- try(fetchChromLengthsFromEnsembl(dataset,
                                                       release=ensembl_release,
                                                       kingdom=kingdom,
                                                       extra_seqnames=extra_seqnames),
                          silent=TRUE)
    }
    if (is(chromlengths, "try-error")) {
      message("FAILED! (=> skipped)")
      return(NULL)
    }
    chrominfo <- data.frame(
            chrom=chromlengths$name,
            length=chromlengths$length,
            is_circular=GenomeInfoDb:::make_circ_flags_from_circ_seqs(
                    chromlengths$name,
                    circ_seqs)
    )
    message("OK")
    return(chrominfo)
  }
  NULL
}

## User-friendly wrapper to .makeBiomartChrominfo().
getChromInfoFromBiomart <- function(biomart="ENSEMBL_MART_ENSEMBL",
                                    dataset="hsapiens_gene_ensembl",
                                    id_prefix="ensembl_",
                                    host="https://www.ensembl.org",
                                    port)
{
  if (!missing(port))
          warning("The 'port' argument is deprecated and will be ignored.")
  mart <- .useMart2(biomart=biomart, dataset=dataset, host=host)
  id_prefix <- .normarg_id_prefix(id_prefix)
  recognized_attribs <- GenomicFeatures:::recognizedBiomartAttribs(id_prefix)
  transcripts <- .makeBiomartTranscripts(NULL, mart,
                                         transcript_ids=NULL,
                                         recognized_attribs,
                                         id_prefix)
  chrominfo <- .makeBiomartChrominfo(mart,
                                     extra_seqnames=transcripts$tx_chrom,
                                     host=host)
  chrominfo[ , 1:2, drop=FALSE]
}


### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
### Download and preprocess the 'splicings' data frame.
###

.extract_numeric_attrib <- function(bm_result, attrib)
{
  ans <- bm_result[[attrib]]
  if (is.numeric(ans))
          return(ans)
  if (is.logical(ans) && all(is.na(ans)))
          return(as.integer(ans))
  stop(wmsg("BioMart fatal data anomaly: ",
            "\"", attrib, "\" attribute is not numeric"))
}

.generate_BioMart_data_anomaly_report <- function(error_type, bm_result, idx,
                                                  id_prefix, msg)
{
  ## Part 3.
  tx_name_colname <- paste0(id_prefix, "transcript_id")
  tx_name <- bm_result[[tx_name_colname]]
  first_tx_names <- unique(tx_name[idx])
  total_nb_tx <- length(first_tx_names)
  first_three_only <- total_nb_tx > 3L
  if (first_three_only)
          first_tx_names <- first_tx_names[1:3]
  bm_result <- S4Vectors:::extract_data_frame_rows(bm_result,
                                                   tx_name %in% first_tx_names)
  bm_result0 <- bm_result[-match(tx_name_colname, names(bm_result))]
  f <- factor(bm_result[[tx_name_colname]], levels=first_tx_names)
  first_tx_tables <- split(bm_result0, f)
  .DETAILS_INDENT <- "     "
  options(width=getOption("width")-nchar(.DETAILS_INDENT))
  part3 <- lapply(seq_len(length(first_tx_tables)),
                  function(i) {
                    tx_table <- first_tx_tables[[i]]
                    if ("rank" %in% colnames(tx_table)) {
                      oo <- order(tx_table[["rank"]])
                      tx_table <-
                              S4Vectors:::extract_data_frame_rows(tx_table, oo)
                    } else {
                      rownames(tx_table) <- NULL
                    }
                    subtitle <- paste0("  ", i, ". Transcript ",
                                       names(first_tx_tables)[i],
                                       ":")
                    details <- capture.output(print(tx_table))
                    c(subtitle, paste0(.DETAILS_INDENT, details))
                  })
  options(width=getOption("width")+nchar(.DETAILS_INDENT))
  part3 <- unlist(part3, use.names=FALSE)
  if (first_three_only)
          part3 <- c(paste("  (Showing only the first 3 out of",
                           total_nb_tx,
                           "transcripts.)"),
                     part3)

  ## Part 1.
  part1 <- paste0(error_type, ": in the following transcripts, ")

  ## Part 2.
  msg[length(msg)] <- paste0(msg[length(msg)], ".")
  part2 <- paste0("  ", msg)

  ## Assemble the parts.
  paste(c(part1, part2, part3), collapse="\n")
}

.stop_on_BioMart_data_anomaly <- function(bm_result, idx, id_prefix, msg)
{
  msg <- .generate_BioMart_data_anomaly_report("BioMart fatal data anomaly",
                                               bm_result, idx, id_prefix, msg)
  new_length <- nchar(msg) + 5L
  ## 8170L seems to be the maximum possible value for the 'warning.length'
  ## option on my machine (R-2.15 r58124, 64-bit Ubuntu).
  if (new_length > 8170L)
          new_length <- 8170L
  if (new_length >= getOption("warning.length")) {
    old_length <- getOption("warning.length")
    on.exit(options(warning.length=old_length))
    options(warning.length=new_length)
  }
  stop(msg)
}

.warning_on_BioMart_data_anomaly <- function(bm_result, idx, id_prefix, msg)
{
  msg <- .generate_BioMart_data_anomaly_report("BioMart data anomaly",
                                               bm_result, idx, id_prefix, msg)
  new_length <- nchar(msg) + 5L
  ## 8170L seems to be the maximum possible value for the 'warning.length'
  ## option on my machine (R-2.15 r58124, 64-bit Ubuntu).
  if (new_length > 8170L)
          new_length <- 8170L
  if (new_length >= getOption("warning.length")) {
    old_length <- getOption("warning.length")
    on.exit(options(warning.length=old_length))
    options(warning.length=new_length)
  }
  warning(msg)
}

.has_utr <- function(utr_start, utr_end, exon_start, exon_end,
                     what_utr, bm_result, id_prefix="ensembl_")
{
  is_na <- is.na(utr_start)
  if (!identical(is_na, is.na(utr_end)))
          stop(wmsg("BioMart fatal data anomaly: ",
                    "NAs in \"", what_utr, "_utr_start\" attribute don't match ",
                    "NAs in \"", what_utr, "_utr_end\" attribute"))
  idx <- which(utr_start > utr_end + 1L)
  if (length(idx) != 0L) {
    msg <- paste0("the ", what_utr, "' UTRs have a start > end + 1")
    .stop_on_BioMart_data_anomaly(bm_result, idx, id_prefix, msg)
  }
  idx <- which(utr_start < exon_start | exon_end < utr_end)
  if (length(idx) != 0L) {
    msg <- paste0("the ", what_utr, "' UTRs ",
                  "are not within the exon limits")
    .stop_on_BioMart_data_anomaly(bm_result, idx, id_prefix, msg)
  }
  !(is_na | utr_start == utr_end + 1L)
}

.extract_cds_ranges_from_C1 <- function(bm_result, id_prefix="ensembl_")
{
  cds_start <- .extract_numeric_attrib(bm_result, "genomic_coding_start")
  cds_end <- .extract_numeric_attrib(bm_result, "genomic_coding_end")
  is_na <- is.na(cds_start)
  if (!identical(is_na, is.na(cds_end)))
          stop(wmsg("BioMart fatal data anomaly: ",
                    "NAs in \"genomic_coding_start\" attribute don't match ",
                    "NAs in \"genomic_coding_end\" attribute"))

  ## Exons with no CDS get a CDS of width 0.
  no_cds_idx <- which(is_na)
  exon_start <- bm_result[["exon_chrom_start"]]
  cds_start[no_cds_idx] <- exon_start[no_cds_idx]
  cds_end[no_cds_idx] <- cds_start[no_cds_idx] - 1L

  IRanges::IRanges(start=cds_start, end=cds_end)
}

### These errors in UTR representation are non fatal but trigger rejection of
### the corresponding transcripts with a warning.
.BIOMART_UTR_ERROR <- c(
        "located on the + strand, \"5_utr_start\" must match \"exon_chrom_start\"",
        "located on the + strand, \"3_utr_end\" must match \"exon_chrom_end\"",
        "located on the - strand, \"3_utr_start\" must match \"exon_chrom_start\"",
        "located on the - strand, \"5_utr_end\" must match \"exon_chrom_end\""
)

.warning_on_BioMart_utr_anomaly <- function(bm_result, idx, id_prefix,
                                            utr_anomaly)
{
  msg <- c(.BIOMART_UTR_ERROR[[utr_anomaly]],
           " (these transcripts were dropped)")
  .warning_on_BioMart_data_anomaly(bm_result, idx, id_prefix, msg)
}

.extract_cds_ranges_from_C2 <- function(bm_result, id_prefix="ensembl_")
{
  strand <- bm_result[["strand"]]
  if (!all(strand %in% c(1, -1)))
          stop(wmsg("BioMart fatal data anomaly: ",
                    "\"strand\" attribute should be 1 or -1"))

  cds_start <- exon_start <- bm_result[["exon_chrom_start"]]
  cds_end <- exon_end <- bm_result[["exon_chrom_end"]]
  utr_anomaly <- integer(nrow(bm_result))

  utr5_start <- .extract_numeric_attrib(bm_result, "5_utr_start")
  utr5_end <- .extract_numeric_attrib(bm_result, "5_utr_end")
  utr3_start <- .extract_numeric_attrib(bm_result, "3_utr_start")
  utr3_end <- .extract_numeric_attrib(bm_result, "3_utr_end")

  has_utr5 <- .has_utr(utr5_start, utr5_end, exon_start, exon_end,
                       "5", bm_result, id_prefix)
  has_utr3 <- .has_utr(utr3_start, utr3_end, exon_start, exon_end,
                       "3", bm_result, id_prefix)

  idx <- which(strand == 1 & has_utr5)
  bad_idx <- idx[utr5_start[idx] != exon_start[idx]]
  if (length(bad_idx) != 0L)
          .warning_on_BioMart_utr_anomaly(bm_result, bad_idx, id_prefix,
                                          utr_anomaly[bad_idx] <- 1L)
  cds_start[idx] <- utr5_end[idx] + 1L

  idx <- which(strand == 1 & has_utr3)
  bad_idx <- idx[utr3_end[idx] != exon_end[idx]]
  if (length(bad_idx) != 0L)
          .warning_on_BioMart_utr_anomaly(bm_result, bad_idx, id_prefix,
                                          utr_anomaly[bad_idx] <- 2L)
  cds_end[idx] <- utr3_start[idx] - 1L

  idx <- which(strand == -1 & has_utr3)
  bad_idx <- idx[utr3_start[idx] != exon_start[idx]]
  if (length(bad_idx) != 0L)
          .warning_on_BioMart_utr_anomaly(bm_result, bad_idx, id_prefix,
                                          utr_anomaly[bad_idx] <- 3L)
  cds_start[idx] <- utr3_end[idx] + 1L

  idx <- which(strand == -1 & has_utr5)
  bad_idx <- idx[utr5_end[idx] != exon_end[idx]]
  if (length(bad_idx) != 0L)
          .warning_on_BioMart_utr_anomaly(bm_result, bad_idx, id_prefix,
                                          utr_anomaly[bad_idx] <- 4L)
  cds_end[idx] <- utr5_start[idx] - 1L

  ## Exons with no CDS get a CDS of width 0.
  cds_relative_start <- bm_result[["cds_start"]]
  no_cds_idx <- which(is.na(cds_relative_start))
  cds_end[no_cds_idx] <- cds_start[no_cds_idx] - 1L

  ans <- IRanges::IRanges(start=cds_start, end=cds_end)
  mcols(ans) <- DataFrame(utr_anomaly=utr_anomaly)
  ans
}

.check_cds <- function(cds_ranges, cds_width, bm_result, id_prefix="ensembl_")
{
  idx <- which(width(cds_ranges) != cds_width)
  if (length(idx) != 0L) {
    msg <- c("the CDS/UTR genomic coordinates are inconsistent with the ",
             "\"cds_start\" and \"cds_end\" attributes")
    .warning_on_BioMart_data_anomaly(bm_result, idx, id_prefix, msg)
  }

  tx_name_colname <- paste0(id_prefix, "transcript_id")
  tx_name <- bm_result[ , tx_name_colname]
  cds_length2 <- sapply(split(width(cds_ranges), tx_name), sum)
  cds_length2 <- cds_length2[as.character(tx_name)]

  cds_length <- bm_result$cds_length
  if (!is.null(cds_length)) {
    idx <- which(cds_length2 != cds_length)
    if (length(idx) != 0L) {
      msg <- c("the CDS length inferred from the CDS/UTR genomic ",
               "coordinates doesn't match the \"cds_length\" attribute")
      .warning_on_BioMart_data_anomaly(bm_result, idx, id_prefix, msg)
    }
  }

  ## Too many transcripts in the ensembl/hsapiens_gene_ensembl dataset don't
  ## pass the sanity check below (20256 transcripts in Ensembl release 75).
  ## This makes makeTxDbFromBiomart() a little bit too noisy so we
  ## comment this out for now.
  #idx <- which(cds_length2 %% 3L != 0L)
  #if (length(idx) != 0L) {
  #    msg <- c("the CDS length inferred from the CDS/UTR genomic ",
  #             "coordinates is not a multiple of 3")
  #    .warning_on_BioMart_data_anomaly(bm_result, idx, id_prefix, msg)
  #}
}

.extract_cds_ranges_from_bm_result <- function(bm_result, id_prefix="ensembl_")
{
  if (nrow(bm_result) == 0L)
          return(IRanges())

  exon_start <- bm_result[["exon_chrom_start"]]
  exon_end <- bm_result[["exon_chrom_end"]]
  if (!is.numeric(exon_start) || !is.numeric(exon_end))
          stop("BioMart data anomaly: \"exon_chrom_start\" and/or ",
               "\"exon_chrom_end\" attributes are not numeric")

  ## BE AWARE that the "cds_start" and "cds_end" attributes that we get
  ## from BioMart are the CDS coordinates relative to the coding mRNA!
  ## See IMPORTANT NOTE ABOUT GROUP D1 in findCompatibleMarts.R for more
  ## information.
  cds_relative_start <- .extract_numeric_attrib(bm_result, "cds_start")
  cds_relative_end <- .extract_numeric_attrib(bm_result, "cds_end")
  is_na <- is.na(cds_relative_start)
  if (!identical(is_na, is.na(cds_relative_end)))
          stop("BioMart data anomaly: ",
               "NAs in \"cds_start\" attribute don't match ",
               "NAs in \"cds_end\" attribute")
  no_cds_idx <- which(is_na)
  cds_width <- cds_relative_end - cds_relative_start + 1L
  cds_width[no_cds_idx] <- 0L

  C1_attribs <- GenomicFeatures:::recognizedBiomartAttribs(id_prefix)[["C1"]]
  has_C1_attribs <- all(C1_attribs %in% colnames(bm_result))
  C2_attribs <- GenomicFeatures:::recognizedBiomartAttribs(id_prefix)[["C2"]]
  has_C2_attribs <- all(C2_attribs %in% colnames(bm_result))

  if (has_C1_attribs)
          ans1 <- .extract_cds_ranges_from_C1(bm_result, id_prefix)
  if (has_C2_attribs) {
    ans2 <- .extract_cds_ranges_from_C2(bm_result, id_prefix)
    utr_anomaly <- mcols(ans2)$utr_anomaly
    tx_name_colname <- paste0(id_prefix, "transcript_id")
    tx_name <- bm_result[ , tx_name_colname]
    invalid_tx <- unique(tx_name[utr_anomaly != 0L])
    valid_tx_idx <- !(tx_name %in% invalid_tx)
    if (has_C1_attribs) {
      ## Check that 'ans1' agrees with 'ans2'.
      if (!identical(width(ans1)[valid_tx_idx],
                     width(ans2)[valid_tx_idx]))
              stop(wmsg("BioMart fatal data anomaly: ",
                        "CDS genomic coordinates are inconsistent with ",
                        "UTR genomic coordinates"))
      cds_idx <- which(valid_tx_idx & width(ans1) != 0L)
      if (!identical(start(ans1)[cds_idx], start(ans2)[cds_idx]))
              stop(wmsg("BioMart fatal data anomaly: ",
                        "CDS genomic coordinates are inconsistent with ",
                        "UTR genomic coordinates"))
    }
    ans1 <- ans2
  } else {
    valid_tx_idx <- seq_along(nrow(bm_result))
  }

  ## More checking of the CDS of the "valid" transcripts ("valid" here means
  ## with no UTR anomalies).
  .check_cds(ans1[valid_tx_idx], cds_width[valid_tx_idx],
             S4Vectors:::extract_data_frame_rows(bm_result, valid_tx_idx),
             id_prefix="ensembl_")
  ans1
}

.make_cds_df_from_ranges <- function(cds_ranges)
{
  no_cds_idx <- which(width(cds_ranges) == 0L)
  cds_start <- start(cds_ranges)
  cds_start[no_cds_idx] <- NA_integer_
  cds_end <- end(cds_ranges)
  cds_end[no_cds_idx] <- NA_integer_
  ans <- data.frame(cds_start=cds_start, cds_end=cds_end)
  utr_anomaly <- mcols(cds_ranges)$utr_anomaly
  if (!is.null(utr_anomaly))
          ans$utr_anomaly <- utr_anomaly
  ans
}

.makeBiomartSplicings <- function(filter, mart, transcripts_tx_id,
                                  recognized_attribs, id_prefix="ensembl_")
{
  ## Those are the strictly required fields.
  splicings0 <- data.frame(
          tx_id=integer(0),
          exon_rank=integer(0),
          exon_start=integer(0),
          exon_end=integer(0)
  )
  if (length(transcripts_tx_id) == 0L)
          return(splicings0)
  message("Download and preprocess the 'splicings' data frame ... ",
          appendLF=FALSE)
  available_attribs <- biomaRt::listAttributes(mart)$name
  has_group <- sapply(recognized_attribs[c("E2", "C1", "C2", "D1", "D2")],
                      function(attribs) all(attribs %in% available_attribs))
  get_groups <- c("E1", names(has_group)[has_group])
  attributes <- unlist(recognized_attribs[get_groups], use.names=FALSE)
  bm_result <- .getBM2(attributes, filter, mart=mart, bmHeader=FALSE)
  tx_name_colname <- paste0(id_prefix, "transcript_id")
  tx_name <- bm_result[[tx_name_colname]]
  splicings_tx_id <- transcripts_tx_id[tx_name]
  exon_name_colname <- paste0(id_prefix, "exon_id")
  splicings <- data.frame(
          tx_id=splicings_tx_id,
          exon_rank=bm_result$rank,
          exon_name=bm_result[[exon_name_colname]],
          exon_start=bm_result$exon_chrom_start,
          exon_end=bm_result$exon_chrom_end
  )
  if ((has_group[['C1']] || has_group[['C2']]) && has_group[['D1']]) {
    cds_ranges <- .extract_cds_ranges_from_bm_result(bm_result, id_prefix)
    splicings <- cbind(splicings, .make_cds_df_from_ranges(cds_ranges))
  }
  message("OK")
  splicings
}


### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
### Download and preprocess the 'genes' data frame.
###

.makeBiomartGenes <- function(filter, mart,
                              transcripts_tx_id, recognized_attribs,
                              id_prefix="ensembl_")
{
  message("Download and preprocess the 'genes' data frame ... ",
          appendLF=FALSE)
  attributes <- c(recognized_attribs[['G']],
                  paste0(id_prefix, "transcript_id"))
  bm_result <- .getBM2(attributes, filter, mart=mart, bmHeader=FALSE)
  tx_name_colname <- paste0(id_prefix, "transcript_id")
  gene_id_colname <- paste0(id_prefix, "gene_id")
  tx_name <- bm_result[[tx_name_colname]]
  gene_id <- bm_result[[gene_id_colname]]
  keep_idx <- which(tx_name %in% names(transcripts_tx_id))
  tx_id <- transcripts_tx_id[tx_name[keep_idx]]
  gene_id <- gene_id[keep_idx]
  message("OK")
  data.frame(
          tx_id=tx_id,
          gene_id=gene_id
  )
}


### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
### Prepare the 'metadata' data frame.
###

.prepareBiomartMetadata <- function(mart, is_full_dataset, host,
                                    taxonomyId, miRBaseBuild)
{
  message("Prepare the 'metadata' data frame ... ",
          appendLF=FALSE)
  biomart <- biomaRt:::martBM(mart)
  dataset <- biomaRt:::martDataset(mart)
  mart_url <- biomaRt:::martHost(mart)
  mart_url <- sub("^[^/]+//", "", mart_url)
  mart_url <- unlist(strsplit(mart_url, "/"))[1]
  db_version <- .getBiomartDbVersion(host, biomart)
  datasets <- biomaRt::listDatasets(mart)
  dataset_rowidx <- which(as.character(datasets$dataset) == dataset)
  ## This should never happen (the earlier call to useMart() would have
  ## failed in the first place).
  if (length(dataset_rowidx) != 1L)
          stop(wmsg("the BioMart database \"", biomaRt:::martBM(mart),
                    "\" has no (or more than one) \"", dataset, "\" datasets"))
  description <- as.character(datasets$description)[dataset_rowidx]
  dataset_version <- as.character(datasets$version)[dataset_rowidx]
  ensembl_release <- .get_Ensembl_release_from_db_version(db_version)
  kingdom <- .get_EnsemblGenomes_kingdom_from_biomart(biomart)
  organism <- GenomicFeatures:::get_organism_from_Ensembl_Mart_dataset(dataset,
                                                     release=ensembl_release,
                                                     kingdom=kingdom)
  if(is.na(taxonomyId)){
    taxonomyId <- GenomeInfoDb:::lookup_tax_id_by_organism(organism)
  }else{
    GenomeInfoDb:::check_tax_id(taxonomyId)
  }

  if (!S4Vectors::isSingleStringOrNA(miRBaseBuild))
          stop(wmsg("'miRBaseBuild' must be a a single string or NA"))
  message("OK")
  data.frame(
          name=c("Data source",
                 "Organism",
                 "Taxonomy ID",
                 "Resource URL",
                 "BioMart database",
                 "BioMart database version",
                 "BioMart dataset",
                 "BioMart dataset description",
                 "BioMart dataset version",
                 "Full dataset",
                 "miRBase build ID"),
          value=c("BioMart",
                  organism,
                  taxonomyId,
                  mart_url,
                  biomart,
                  db_version,
                  dataset,
                  description,
                  dataset_version,
                  ifelse(is_full_dataset, "yes", "no"),
                  miRBaseBuild)
  )
}


### - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
### makeTxDbFromBiomart()
###

makeTxDbFromBiomart <- function(biomart="ENSEMBL_MART_ENSEMBL",
                                dataset="hsapiens_gene_ensembl",
                                transcript_ids=NULL,
                                circ_seqs=NULL,
                                filter=NULL,
                                id_prefix="ensembl_",
                                host="https://www.ensembl.org",
                                port,
                                taxonomyId=NA,
                                miRBaseBuild=NA)
{
  if (!missing(port))
          warning("The 'port' argument is deprecated and will be ignored.")
  mart <- .useMart2(biomart=biomart, dataset=dataset, host=host)
  id_prefix <- .normarg_id_prefix(id_prefix)
  filter <- .add_tx_id_filter(filter, transcript_ids, id_prefix)
  valid_filter_names <- biomaRt::listFilters(mart, what="name")
  invalid_filter_names <- setdiff(names(filter), valid_filter_names)
  if (length(invalid_filter_names) != 0L) {
    in1string <- paste0(invalid_filter_names, collapse=", ")
    stop(wmsg("Invalid filter name(s): ", in1string,
              "\n\nPlease use the biomaRt::listFilters() function from the ",
              "biomaRt package to get valid filter names."))
  }
  is_full_dataset <- length(filter) == 0L
  recognized_attribs <- GenomicFeatures:::recognizedBiomartAttribs(id_prefix)

  transcripts <- .makeBiomartTranscripts(filter, mart,
                                         transcript_ids,
                                         recognized_attribs,
                                         id_prefix)
  transcripts_tx_id <- transcripts$tx_id
  names(transcripts_tx_id) <- transcripts$tx_name
  chrominfo <- .makeBiomartChrominfo(mart,
                                     extra_seqnames=transcripts$tx_chrom,
                                     circ_seqs=circ_seqs,
                                     host)
  if (!is_full_dataset) {
    keep_idx <- which(chrominfo[ , "chrom"] %in% transcripts$tx_chrom)
    chrominfo <- S4Vectors:::extract_data_frame_rows(chrominfo, keep_idx)
  }
  splicings <- .makeBiomartSplicings(filter, mart,
                                     transcripts_tx_id,
                                     recognized_attribs,
                                     id_prefix=id_prefix)

  ## Drop transcripts with UTR anomalies.
  utr_anomaly <- splicings$utr_anomaly
  if (!is.null(utr_anomaly)) {
    invalid_tx <- unique(splicings[utr_anomaly != 0L, "tx_id"])
    if (length(invalid_tx) != 0L) {
      message("Drop transcripts with UTR anomalies (",
              length(invalid_tx), " transcripts) ... ",
              appendLF=FALSE)
      keep_idx1 <- !(transcripts$tx_id %in% invalid_tx)
      transcripts <- S4Vectors:::extract_data_frame_rows(transcripts,
                                                         keep_idx1)
      transcripts_tx_id <- transcripts_tx_id[keep_idx1]
      keep_idx2 <- !(splicings$tx_id %in% invalid_tx)
      splicings <- S4Vectors:::extract_data_frame_rows(splicings,
                                                       keep_idx2)
      message("OK")
    }
    splicings$utr_anomaly <- NULL
  }

  genes <- .makeBiomartGenes(filter, mart, transcripts_tx_id,
                             recognized_attribs, id_prefix)
  metadata <- .prepareBiomartMetadata(mart, is_full_dataset,
                                      host, taxonomyId, miRBaseBuild)

  message("Make the TxDb object ... ", appendLF=FALSE)
  txdb <- makeTxDb(transcripts, splicings,
                   genes=genes, chrominfo=chrominfo,
                   metadata=metadata, reassign.ids=TRUE)
  message("OK")
  txdb
}

biomartURL <- gsub("https:", "http:", biomartURL)
# biomartURL <- gsub("http:", "https:", biomartURL)


txdb = GenomicFeatures::makeTxDbFromBiomart(
    biomart = "ENSEMBL_MART_ENSEMBL",
    dataset = selString,
    host= biomartURL
)

## Use legacy function defined above:
# txdb = makeTxDbFromBiomart(
#         biomart = "ENSEMBL_MART_ENSEMBL",
#         dataset = selString,
#         host=biomartURL
# )
#
#

txdb_file = tempfile(pattern = "file", tmpdir = tempdir(), fileext = ".rds")
AnnotationDbi::saveDb(txdb, txdb_file)

txdb = AnnotationDbi::loadDb(txdb_file)

exons = ensembldb::exonsBy(txdb, by = "tx", use.names = T)
cdss = ensembldb::cdsBy(txdb, by = "tx", use.names = T)


```


```{r set_region_var, eval=T}
## Setup plot collection object




## Load R module load R/3.5.1-foss-2018b ##
#setwd(Obio@parameterList$workdir)
#######
## Function plotCoverage from wiggleplotR.r
#' Quickly plot transcript structure without read coverage tracks
#'
#' @param exons list of GRanges objects, each object containing exons for one transcript.
#' The list must have names that correspond to transcript_id column in transript_annotations data.frame.
#' @param cdss list of GRanges objects, each object containing the coding regions (CDS) of a single transcript. 
#' The list must have names that correspond to transcript_id column in transript_annotations data.frame. 
#' If cdss is not specified then exons list will be used for both arguments. (default: NULL)
#' @param transcript_annotations Data frame with at least three columns: transcript_id, gene_name, strand.
#' Used to construct transcript labels. (default: NULL)
#' @param rescale_introns Specifies if the introns should be scaled to fixed length or not. (default: TRUE)
#' @param new_intron_length length (bp) of introns after scaling. (default: 50)
#' @param flanking_length Lengths of the flanking regions upstream and downstream of the gene. (default: c(50,50))
#' @param connect_exons Print lines that connect exons together. Set to FALSE when plotting peaks (default: TRUE).
#' @param transcript_label If TRUE then transcript labels are printed above each transcript. (default: TRUE). 
#' @param region_coords Start and end coordinates of the region to plot, overrides flanking_length parameter.
#'
#' @return ggplot2 object
#' @examples
#' plotTranscripts(ncoa7_exons, ncoa7_cdss, ncoa7_metadata, rescale_introns = FALSE)
#' 
#' @export

joinExons <- function(exons) {
  #Join a list of exons into one GRanges object
  
  #Test that all transcripts are on the same chromosome
  chrs = purrr::map_chr(as.list(exons), ~GenomicRanges::seqnames(.)[1] %>% 
                              S4Vectors::as.vector.Rle(mode = "character"))
  if (!all(chrs == chrs[1])){
    stop("Some transcripts are on different chromosomes.")
  }
  
  #Join all exons together
  transcript_ids = names(exons)
  joint_exons = c()
  for(tx_id in transcript_ids){
    tx = exons[[tx_id]]
    if(length(joint_exons) == 0){
      joint_exons = tx
    }
    else{
      joint_exons = c(joint_exons, tx)
    }
  }
  joint_exons = GenomicRanges::reduce(joint_exons)
  return(joint_exons)
}

extractStrandsFromGrangesList <- function(granges_list){
  strands = purrr::map(as.list(granges_list), ~(GenomicRanges::strand(.) %>%
                         S4Vectors::as.vector.Rle(.,"character"))[1])
  return(unlist(strands))
}


prepareTranscriptAnnotations <- function(transcript_annotations){
  assertthat::assert_that(assertthat::has_name(transcript_annotations, "transcript_id"))
  assertthat::assert_that(assertthat::has_name(transcript_annotations, "strand"))
  
  
  #Make sure that the strand information is represented correctly
  transcript_annotations = dplyr::mutate(transcript_annotations,
                                         strand = ifelse(strand %in% c("+","*") | strand == 1, 1, -1))
  
  #Add transcript label
  if(assertthat::has_name(transcript_annotations, "gene_name")){
    transcript_annotations = dplyr::select_(transcript_annotations, "transcript_id", "gene_name", "strand") %>% 
      dplyr::mutate(transcript_label = ifelse(strand == 1, 
                    paste(paste(gene_name, transcript_id, sep = ":")," >",sep =""), 
                    paste("< ",paste(gene_name, transcript_id, sep = ":"),sep ="")))
  } else{
    transcript_annotations = dplyr::mutate(transcript_annotations, transcript_label = ifelse(strand == 1, 
                    paste(paste(transcript_id, sep = ":")," >",sep =""), 
                    paste("< ",paste(transcript_id, sep = ":"),sep =""))) 
  }
  return(transcript_annotations)
}


prepareTranscriptAnnotations <- function(transcript_annotations){
  assertthat::assert_that(assertthat::has_name(transcript_annotations, "transcript_id"))
  assertthat::assert_that(assertthat::has_name(transcript_annotations, "strand"))
  
  
  #Make sure that the strand information is represented correctly
  transcript_annotations = dplyr::mutate(transcript_annotations,
                                         strand = ifelse(strand %in% c("+","*") | strand == 1, 1, -1))
  
  #Add transcript label
  if(assertthat::has_name(transcript_annotations, "gene_name")){
    transcript_annotations = dplyr::select_(transcript_annotations, "transcript_id", "gene_name", "strand") %>% 
      dplyr::mutate(transcript_label = ifelse(strand == 1, 
                    paste(paste(gene_name, transcript_id, sep = ":")," >",sep =""), 
                    paste("< ",paste(gene_name, transcript_id, sep = ":"),sep ="")))
  } else{
    transcript_annotations = dplyr::mutate(transcript_annotations, transcript_label = ifelse(strand == 1, 
                    paste(paste(transcript_id, sep = ":")," >",sep =""), 
                    paste("< ",paste(transcript_id, sep = ":"),sep =""))) 
  }
  return(transcript_annotations)
}


plotTranscripts <- function(exons, cdss = NULL, transcript_annotations = NULL, 
                            rescale_introns = TRUE, new_intron_length = 50, 
                            flanking_length = c(50,50), connect_exons = TRUE, 
                            transcript_label = TRUE, region_coords = NULL){
  
  #IF cdss is not specified then use exons instead on cdss
  if(is.null(cdss)){
    cdss = exons
  }
  
  #Check exons and cdss
  assertthat::assert_that(is.list(exons)|| is(exons, "GRangesList")) #Check that exons and cdss objects are lists
  assertthat::assert_that(is.list(cdss) || is(exons, "GRangesList"))
  
  #Join exons together
  joint_exons = joinExons(exons)
  
  #Extract chromosome name
  chromosome_name = as.vector(GenomicRanges::seqnames(joint_exons)[1])
  
  #If region_coords is specificed, then ignore the flanking_length attrbute and compute
  # flanking_length form region_coords
  if(!is.null(region_coords)){
    gene_range = constructGeneRange(joint_exons, c(0,0))
    min_start = min(GenomicRanges::start(gene_range))
    max_end = max(GenomicRanges::end(gene_range))
    flanking_length = c(min_start - region_coords[1], region_coords[2] - max_end)
  }
  #Make sure that flanking_length is a vector of two elements
  assertthat::assert_that(length(flanking_length) == 2) 

  #Rescale introns
  if (rescale_introns){
    tx_annotations = rescaleIntrons(exons, cdss, joint_exons, new_intron_length = new_intron_length, flanking_length)
    xlabel = "Distance from region start (bp)"
  } else {
    old_introns = intronsFromJointExonRanges(GenomicRanges::ranges(joint_exons), flanking_length = flanking_length)
    tx_annotations = list(exon_ranges = lapply(exons, GenomicRanges::ranges), cds_ranges = lapply(cdss, GenomicRanges::ranges),
                          old_introns = old_introns, new_introns = old_introns)
    
    xlabel = paste("Chromosome", chromosome_name, "position (bp)")
  }
  
  #If transcript annotations are not supplied then construct them manually from the GRanges list
  if(is.null(transcript_annotations)){
    plotting_annotations = dplyr::tibble(transcript_id = names(exons),
                                             strand = extractStrandsFromGrangesList(exons)) %>%
      prepareTranscriptAnnotations()
  } else{
    plotting_annotations = prepareTranscriptAnnotations(transcript_annotations)
  }
  
  #Plot transcript structures
  limits = c( min(IRanges::start(tx_annotations$new_introns)), max(IRanges::end(tx_annotations$new_introns)))
  structure = prepareTranscriptStructureForPlotting(tx_annotations$exon_ranges, 
                                               tx_annotations$cds_ranges, plotting_annotations)
  plot = plotTranscriptStructure(structure, limits, connect_exons = connect_exons, xlabel = xlabel, 
                                 transcript_label = transcript_label)
  return(plot)
}

#' Plot read coverage across genomic regions
#' 
#' Also supports rescaling introns to constant length. Does not work 
#' on Windows, because rtracklayer cannot read BigWig files on Windows.
#' 
#' @param exons list of GRanges objects, each object containing exons for one transcript. 
#' The list must have names that correspond to transcript_id column in transript_annotations data.frame.
#' @param cdss list of GRanges objects, each object containing the coding regions (CDS) of a single transcript. 
#' The list must have names that correspond to transcript_id column in transript_annotations data.frame. 
#' If cdss is not specified then exons list will be used for both arguments. (default: NULL).
#' @param transcript_annotations Data frame with at least three columns: transcript_id, gene_name, strand. 
#' Used to construct transcript labels. (default: NULL)
#' @param track_data data.frame with the metadata for the bigWig read coverage files. Must contain the following columns:
#' \itemize{
#'  \item sample_id - unique id for each sample.
#'  \item track_id - if multiple samples (bigWig files) have the same track_id they will be overlayed on the same 
#' plot, track_id is also used as the facet label on the right.
#'  \item bigWig - path to the bigWig file.
#'  \item scaling_factor - normalisation factor for each sample, useful if different samples sequenced to different 
#' depth and bigWig files not normalised for that.
#'  \item colour_group - additional column to group samples into, is used as the colour of the coverage track.
#' }
#' @param rescale_introns Specifies if the introns should be scaled to fixed length or not. (default: TRUE)
#' @param new_intron_length length (bp) of introns after scaling. (default: 50)
#' @param flanking_length Lengths of the flanking regions upstream and downstream of the gene. (default: c(50,50))
#' @param plot_fraction Size of the random sub-sample of points used to plot coverage (between 0 and 1). 
#' Smaller values make plotting significantly faster. (default: 0.1)
#' @param heights  Specifies the proportion of the height that is dedicated to coverage plots (first value) 
#' relative to transcript annotations (second value). (default: c(0.75,0.25))
#' @param alpha Transparency (alpha) value for the read coverage tracks. 
#' Useful to set to something < 1 when overlaying multiple tracks (see track_id). (default: 1)
#' @param fill_palette Vector of fill colours used for the coverage tracks. Length must be equal to the number of 
#' unique values in track_data$colour_group column.
#' @param mean_only Plot only mean coverage within each combination of track_id and colour_group values. 
#' Useful for example for plotting mean coverage stratified by genotype (which is specified in the colour_group column) (default: TRUE).
#' @param connect_exons Print lines that connect exons together. Set to FALSE when plotting peaks (default: TRUE).
#' @param transcript_label If TRUE then transcript labels are printed above each transcript. (default: TRUE). 
#' @param return_subplots_list Instead of a joint plot return a list of subplots that can be joined together manually. 
#' @param region_coords Start and end coordinates of the region to plot, overrides flanking_length parameter.
#' @param coverage_type Specifies if the read coverage is represented by either 'line', 'area' or 'both'. 
#' The 'both' option tends to give better results for wide regions. (default: area). 
#'
#' @return Either object from cow_plot::plot_grid() function or a list of subplots (if return_subplots_list == TRUE)
#' @examples
#' require("dplyr")
#' require("GenomicRanges")
#' sample_data = dplyr::data_frame(sample_id = c("aipt_A", "aipt_C", "bima_A", "bima_C"), 
#'     condition = factor(c("Naive", "LPS", "Naive", "LPS"), levels = c("Naive", "LPS")), 
#'     scaling_factor = 1) %>%
#'     dplyr::mutate(bigWig = system.file("extdata",  paste0(sample_id, ".str2.bw"), package = "wiggleplotr"))
#' 
#' track_data = dplyr::mutate(sample_data, track_id = condition, colour_group = condition)
#' 
#' selected_transcripts = c("ENST00000438495", "ENST00000392477") #Plot only two transcripts of the gens
#' \dontrun{
#' plotCoverage(ncoa7_exons[selected_transcripts], ncoa7_cdss[selected_transcripts], 
#'    ncoa7_metadata, track_data, 
#'    heights = c(2,1), fill_palette = getGenotypePalette())
#' }
#' 
#' @export
plotCoverage <- function(exons, cdss = NULL, transcript_annotations = NULL, track_data, rescale_introns = TRUE,
                        new_intron_length = 50, flanking_length = c(50,50),
                        plot_fraction = 0.1, heights = c(0.75, 0.25), alpha = 1,
                        fill_palette = c("#a1dab4","#41b6c4","#225ea8"), mean_only = TRUE, 
                        connect_exons = TRUE, transcript_label = TRUE, return_subplots_list = FALSE,
                        region_coords = NULL, coverage_type = "area"){
  
  #IF cdss is not specified then use exons instead on cdss
  if(is.null(cdss)){
    cdss = exons
  }
  
  #Make some assertions about the input data
  #Check track_data
  assertthat::assert_that(assertthat::has_name(track_data, "sample_id"))
  assertthat::assert_that(assertthat::has_name(track_data, "track_id"))
  assertthat::assert_that(assertthat::has_name(track_data, "bigWig"))
  assertthat::assert_that(assertthat::has_name(track_data, "scaling_factor"))
  assertthat::assert_that(assertthat::has_name(track_data, "colour_group"))
  
  #Make sure that bigWig column is not a factor
  if(is.factor(track_data$bigWig)){
    warning("bigWig column in track_data data.frame is a factor, coverting to a character vector.")
    track_data = dplyr::mutate_(track_data, .dots = stats::setNames(list(~as.character(bigWig)), c("bigWig")))
  }
  
  #Check transcript annotation
  #If transcript annotations are not supplied then construct them manually from the GRanges list
  if(is.null(transcript_annotations)){
    plotting_annotations = dplyr::data_frame(transcript_id = names(exons),
                                             strand = extractStrandsFromGrangesList(exons)) %>%
      prepareTranscriptAnnotations()
  } else{
    assertthat::assert_that(assertthat::has_name(transcript_annotations, "transcript_id"))
    assertthat::assert_that(assertthat::has_name(transcript_annotations, "gene_name"))
    assertthat::assert_that(assertthat::has_name(transcript_annotations, "strand"))
    plotting_annotations = prepareTranscriptAnnotations(transcript_annotations)
  }
  
  #Check exons and cdss
  assertthat::assert_that(is.list(exons) || is(exons, "GRangesList")) #Check that exons and cdss objects are lists
  assertthat::assert_that(is.list(cdss) || is(exons, "GRangesList"))
  #TODO: Check that the names of the exons and cdss list match that of the transcript_annotations data.frame
  
  #Find the start and end cooridinates of the whole region spanning the gene
  joint_exons = joinExons(exons)
  
  #If region_coords is specificed, then ignore the flanking_length attrbute and compute
  # flanking_length form region_coords
  if(!is.null(region_coords)){
    gene_range = constructGeneRange(joint_exons, c(0,0))
    min_start = min(GenomicRanges::start(gene_range))
    max_end = max(GenomicRanges::end(gene_range))
    flanking_length = c(min_start - region_coords[1], region_coords[2] - max_end)
    
    gene_range = constructGeneRange(joint_exons, flanking_length)
  } else{
    gene_range = constructGeneRange(joint_exons, flanking_length)
  }
  assertthat::assert_that(length(flanking_length) == 2) #flanking_length is a vector of two elements

  #Extract chromosome name
  chromosome_name = as.vector(GenomicRanges::seqnames(gene_range)[1])

  #Read coverage tracks from BigWig file
  sample_list = as.list(track_data$bigWig)
  names(sample_list) = track_data$sample_id
  coverage_list = lapply(sample_list, readCoverageFromBigWig, gene_range)

  #Shorten introns and translate exons into the new introns
  if(rescale_introns){
    #Recale transcript annotations
    tx_annotations = rescaleIntrons(exons, cdss, joint_exons, 
                                    new_intron_length = new_intron_length, flanking_length = flanking_length)
    #Make a label for gene structure plot
    xlabel = "Distance from region start (bp)"
  }
  else{ #Do not rescale transcript annotationn
    #Need to calculate joint intron coordinates for transcript annotations
    old_introns = intronsFromJointExonRanges(GenomicRanges::ranges(joint_exons), flanking_length = flanking_length)
    tx_annotations = list(exon_ranges = lapply(exons, GenomicRanges::ranges), cds_ranges = lapply(cdss, GenomicRanges::ranges),
                          old_introns = old_introns, new_introns = old_introns)
    
    #Make a label for gene structure plot
    xlabel = paste("Chromosome", chromosome_name, "position (bp)")
  }
  #Shrink intron coverage and convert coverage vectors into data frames
  coverage_list = lapply(coverage_list, shrinkIntronsCoverage, tx_annotations$old_introns, tx_annotations$new_introns)

  #Take a subsample of points that is easier to plot
  points = subsamplePoints(tx_annotations, plot_fraction)
  coverage_list = lapply(coverage_list, function(x) {x[points,]} )

  #Convert to data frame and plot
  coverage_df = purrr::map_df(coverage_list, identity, .id = "sample_id") %>% 
    as.data.frame() %>%
    dplyr::mutate_(.dots = stats::setNames(list(~as.character(sample_id)), c("sample_id")) ) #Convert factor to character
  coverage_df = dplyr::left_join(coverage_df, track_data, by = "sample_id") %>%
    dplyr::mutate_(.dots = stats::setNames(list(~coverage/scaling_factor), c("coverage")) ) #Normalize by library size

  #Calculate mean coverage within each track and colour group
  if(mean_only){  coverage_df = meanCoverage(coverage_df) }
  
  #Make plots
  #Construct transcript structure data.frame from ranges lists
  limits = c( min(IRanges::start(tx_annotations$new_introns)), max(IRanges::end(tx_annotations$new_introns)))
  transcript_struct = prepareTranscriptStructureForPlotting(tx_annotations$exon_ranges, 
                       tx_annotations$cds_ranges, plotting_annotations)
  tx_structure = plotTranscriptStructure(transcript_struct, limits, connect_exons, xlabel, transcript_label)
  
  coverage_plot = makeCoveragePlot(coverage_df, limits, alpha, fill_palette, coverage_type)
  
  #Choose between returning plot list or a joint plot using plot_grid
  if(return_subplots_list){
    plot_list = list(coverage_plot = coverage_plot, tx_structure = tx_structure)
    return(plot_list)
  } else {
    plot = cowplot::plot_grid(coverage_plot, tx_structure, align = "v", rel_heights = heights, ncol = 1)
    return(plot)
  }
}

#Helper function to make wiggle plots

readCoverageFromBigWig <- function(bigwig_path, gene_range){
  #Read coverage over a region from a bigWig file
  sel = rtracklayer::BigWigSelection(gene_range)
  coverage_ranges = rtracklayer::import.bw(bigwig_path, selection = sel)
  GenomeInfoDb::seqlevels(coverage_ranges) = S4Vectors::as.vector.Rle(GenomicRanges::seqnames(gene_range), mode = "character")
  coverage_rle = GenomicRanges::coverage(coverage_ranges, weight = GenomicRanges::score(coverage_ranges))[[1]]
  coverage_rle = coverage_rle[(GenomicRanges::start(gene_range)):(GenomicRanges::end(gene_range))] #Keep the region of interest
}

joinExons <- function(exons) {
  #Join a list of exons into one GRanges object
  
  #Test that all transcripts are on the same chromosome
  chrs = purrr::map_chr(as.list(exons), ~GenomicRanges::seqnames(.)[1] %>% 
                              S4Vectors::as.vector.Rle(mode = "character"))
  if (!all(chrs == chrs[1])){
    stop("Some transcripts are on different chromosomes.")
  }
  
  #Join all exons together
  transcript_ids = names(exons)
  joint_exons = c()
  for(tx_id in transcript_ids){
    tx = exons[[tx_id]]
    if(length(joint_exons) == 0){
      joint_exons = tx
    }
    else{
      joint_exons = c(joint_exons, tx)
    }
  }
  joint_exons = GenomicRanges::reduce(joint_exons)
  return(joint_exons)
}

extractStrandsFromGrangesList <- function(granges_list){
  strands = purrr::map(as.list(granges_list), ~(GenomicRanges::strand(.) %>%
                         S4Vectors::as.vector.Rle(.,"character"))[1])
  return(unlist(strands))
}

prepareTranscriptAnnotations <- function(transcript_annotations){
  assertthat::assert_that(assertthat::has_name(transcript_annotations, "transcript_id"))
  assertthat::assert_that(assertthat::has_name(transcript_annotations, "strand"))
  
  
  #Make sure that the strand information is represented correctly
  transcript_annotations = dplyr::mutate(transcript_annotations,
                                         strand = ifelse(strand %in% c("+","*") | strand == 1, 1, -1))
  
  #Add transcript label
  if(assertthat::has_name(transcript_annotations, "gene_name")){
    transcript_annotations = dplyr::select_(transcript_annotations, "transcript_id", "gene_name", "strand") %>% 
      dplyr::mutate(transcript_label = ifelse(strand == 1, 
                    paste(paste(gene_name, transcript_id, sep = ":")," >",sep =""), 
                    paste("< ",paste(gene_name, transcript_id, sep = ":"),sep ="")))
  } else{
    transcript_annotations = dplyr::mutate(transcript_annotations, transcript_label = ifelse(strand == 1, 
                    paste(paste(transcript_id, sep = ":")," >",sep =""), 
                    paste("< ",paste(transcript_id, sep = ":"),sep =""))) 
  }
  return(transcript_annotations)
}

prepareTranscriptStructureForPlotting <- function(exon_ranges, cds_ranges, transcript_annotations){
  #Combine exon_ranges and cds_ranges into a single data.frame that also contains transcript rank
  
  #Convert exon ranges into data.frame and add transcript rank
  exons_df = purrr::map_df(exon_ranges, data.frame, .id = "transcript_id")
  exons_df = dplyr::mutate(exons_df, transcript_rank = as.numeric(factor(exons_df$transcript_id)), type = "")
  transcript_rank = unique(exons_df[,c("transcript_id", "transcript_rank", "type")])
  
  #Convert CDS ranges into a data.frame
  cds_df = purrr::map_df(cds_ranges, data.frame, .id = "transcript_id")
  cds_df = dplyr::left_join(cds_df, transcript_rank, by = "transcript_id") #Add matching transcript rank
  
  #Join exons and cdss together
  exons_df = dplyr::mutate(exons_df, feature_type = "exon")
  cds_df = dplyr::mutate(cds_df, feature_type = "cds")
  transcript_struct = rbind(exons_df, cds_df)

  #Add transcript label to transcript structure
  transcript_struct = dplyr::left_join(transcript_struct, transcript_annotations, by = "transcript_id")
  return(transcript_struct)
}

intronsFromJointExonRanges <- function(joint_exon_ranges, flanking_length){
  #Construct intron ranges from joint exon ranges
  introns = IRanges::gaps(joint_exon_ranges,
                     start = min(IRanges::start(joint_exon_ranges)) - flanking_length[1], 
                     end = max(IRanges::end(joint_exon_ranges)) + flanking_length[2])
  return(introns)
}

# Find the start and end coordinates of the whole gene form joint exons. 
constructGeneRange <- function(joint_exon_ranges, flanking_length){
  gene_range = GenomicRanges::reduce(c(joint_exon_ranges, GenomicRanges::gaps(joint_exon_ranges, start = NA, end = NA)))
  GenomeInfoDb::seqlevels(gene_range) = S4Vectors::as.vector.Rle(GenomicRanges::seqnames(gene_range), mode = "character")[1]
  GenomicRanges::start(gene_range) = GenomicRanges::start(gene_range) - flanking_length[1]
  GenomicRanges::end(gene_range) = GenomicRanges::end(gene_range) + flanking_length[2]
  return(gene_range)
}

#' Paste two factors together and preserved their joint order.
#'
#' @param factor1 First factor
#' @param factor2 Second factor
#' 
#' @return Factors factor1 and factor2 pasted together.
pasteFactors <- function(factor1, factor2){
  #Extract levels
  levels1 = levels(factor1)
  levels2 = levels(factor2)
  
  #Construct joint levels
  new1 = rep(levels1, length(levels2))
  new2 = rep(levels2, each = length(levels1))
  new_levels = paste(new1, new2, sep = "_")
  
  new_factor = factor(paste(as.character(factor1), as.character(factor2), sep = "_"), levels = new_levels)
  return(new_factor)
}

# Calculate mean coverage within each track_id and colour_group
meanCoverage <- function(coverage_df){
  coverage_df = dplyr::group_by_(coverage_df, "track_id", "colour_group", "bins") %>% 
    dplyr::summarise_(.dots = stats::setNames(list(~mean(coverage)), c("coverage"))) %>%
    dplyr::ungroup() %>% # It's important to do ungroup before mutate, or you get unexpected factor results
    dplyr::mutate_(.dots = stats::setNames(list(~pasteFactors(as.factor(track_id), as.factor(colour_group))),c("sample_id")) ) #Construct a new sample id for mean vector
  
  return(coverage_df)
}

# Choose a subsample of points to make plotting faster
# Makes sure that intron-exon boundaries are well samples.
subsamplePoints <- function(tx_annotations, plot_fraction){
  #Define the start and end coorinates of the region
  region_start = min(IRanges::start(tx_annotations$new_introns))
  region_end = max(IRanges::end(tx_annotations$new_introns))
  region_length = region_end - region_start

  #Take a subsample of points that's easier to plot
  points = sample(region_length, floor(region_length*plot_fraction))
  #Subtract the start coordinate of the region
  exon_starts = unique(unlist(lapply(tx_annotations$exon_ranges, IRanges::start))) - (region_start -1)
  exon_ends = unique(unlist(lapply(tx_annotations$exon_ranges, IRanges::end))) - (region_start - 1)
  points = unique(sort(c(points, exon_starts, exon_ends, 
                         exon_starts -3, exon_starts +3, 
                         exon_ends + 3, exon_ends -3)))
  points = points[points >= 0]
  return(points)
}


#' Returns a three-colour palette suitable for visualising read coverage stratified by genotype
#'
#' @param old Return old colour palette (now deprecated).
#' @return Vector of three colours.
#' @export
#'
#' @examples
#' getGenotypePalette()
getGenotypePalette <- function(old = FALSE){
  if(old){
    c("#d7191c","#fdae61","#1a9641")
  } else{
    #Borrowed from Kumasaka, et al 2015
    c("#E9181D","#51BEEE","#18354B") 
  }
}

#Common theme for all data track plots
dataTrackTheme <- function(){
  theme = theme(axis.text.x = element_blank(), 
                axis.title.x = element_blank(), 
                axis.ticks.x = element_blank(),
                plot.margin=unit(c(0.1,1,0.1,1),"line"),
                legend.position="none",
                panel.grid.major = element_blank(),
                panel.grid.minor = element_blank(),
                strip.text.y = element_text(colour = "grey10"),
                strip.background = element_rect(fill = "grey85"))
  return(theme)
}

shortenIntrons <- function(introns, intron_length){
  #Shorten introns from a fixed length to a variable length
  
  #Calculate neccesary parameters
  exons = IRanges::gaps(introns)
  n_introns = length(introns)
  n_exons = length(exons)
  
  #Calculate cumulative with of introns
  intron_cum_width = seq(intron_length,(n_introns-1)*intron_length,intron_length)
  #Calculate new exon starts ignoring introns
  new_intron_starts = c(1,IRanges::start(introns)[2:n_introns] - (IRanges::end(introns)[1:n_introns-1] - intron_cum_width))
  #Add exon widths to the introns
  new_intron_starts = new_intron_starts + c(0,cumsum(IRanges::width(exons)) - IRanges::width(exons))
  
  new_introns = IRanges::IRanges(start = new_intron_starts, width = rep(intron_length, n_introns))
  return(new_introns)
}

shrinkIntronsCoverage <- function(coverage, old_introns, new_introns){
  
  #Covert coverage vector from Rle to normal vector
  coverage = S4Vectors::as.vector.Rle(coverage, mode = "double")

  #Calculate full annotations
  old_annot = S4Vectors::sort(c(old_introns, IRanges::gaps(old_introns)))
  new_annot = S4Vectors::sort(c(new_introns, IRanges::gaps(new_introns)))
  
  #If new and old annotations are identical then return coverage as data frame
  if(all(IRanges::width(old_annot) == IRanges::width(new_annot))){
    bins = seq(min(IRanges::start(new_annot)), max(IRanges::end(new_annot)))
   
    #Make sure that coverage vector and bins vector have equal length
    assertthat::assert_that(assertthat::are_equal(length(bins), length(coverage)))
    new_coverage = dplyr::data_frame(bins = bins, coverage = coverage)
    return(new_coverage)
    
  } else{ #Otherwise shrink intron converage
    
    #Calculate the width of each annotation bin
    bin_width = ceiling(IRanges::width(old_annot)/IRanges::width(new_annot))
    
    #Build summarisation groups
    s_coord = IRanges::start(new_annot)
    e_coord = IRanges::end(new_annot)
    w_old = IRanges::width(old_annot)
    
    bins = c()
    
    for (i in seq_along(new_annot)){
      bin_id = rep(c(s_coord[i]:e_coord[i]),each = bin_width[i])[1:w_old[i]]
      bins = c(bins, bin_id)
    }
    
    #Calculate mean coverage in bins
    df = data.frame(coverage, bins)
    new_coverage = dplyr::summarize(dplyr::group_by(df, bins), coverage = mean(coverage))
    return(new_coverage)
  }
}

translateExonCoordinates <- function(exons, old_introns, new_introns){
  #Tranlate exon coordinates by shortening introns
  old_exon_starts = IRanges::start(exons)
  old_intron_ends = IRanges::end(old_introns)
  new_intron_ends = IRanges::end(new_introns)
  
  #Translate old exon coordinates to new exon coordinates
  new_exon_starts = rep(0,length(old_exon_starts))
  for (i in seq_along(old_exon_starts)){
    #Find the nearest upstream intron for the current gene
    nearest_intron_number = max(which(old_exon_starts[i] > old_intron_ends))
    new_exon_starts[i] = old_exon_starts[i] - old_intron_ends[nearest_intron_number] + new_intron_ends[nearest_intron_number]
  }
  
  #Create new exon coordinates
  new_exons = IRanges::IRanges(start = new_exon_starts, width = IRanges::width(exons))
  return(new_exons)
}

rescaleIntrons <- function(exons, cdss, joint_exons, new_intron_length, flanking_length){
  
  #Convert exons and cds objects to ranges
  exon_ranges = lapply(exons, GenomicRanges::ranges)
  cds_ranges = lapply(cdss, GenomicRanges::ranges)
  
  #Shorten introns and translate exons into the new exons
  old_introns = intronsFromJointExonRanges(GenomicRanges::ranges(joint_exons), flanking_length = flanking_length)
  new_introns = shortenIntrons(old_introns,new_intron_length)
  new_exon_ranges = lapply(exon_ranges, translateExonCoordinates, old_introns, new_introns)
  new_cds_ranges = lapply(cds_ranges, translateExonCoordinates, old_introns, new_introns)
  
  return(list(exon_ranges = new_exon_ranges, cds_ranges = new_cds_ranges, 
              old_introns = old_introns, new_introns = new_introns))
}

plotTranscriptStructure <- function(exons_df, limits = NA, connect_exons = TRUE,  
                                    xlabel = "Distance from gene start (bp)", transcript_label = TRUE){
  
  #Extract the position for plotting transcript name
  transcript_annot = dplyr::group_by_(exons_df, ~transcript_id) %>% 
    dplyr::filter_(~feature_type == "exon") %>%
    dplyr::arrange_('transcript_id', 'start') %>%
    dplyr::filter(row_number() == 1)

  #Create a plot of transcript structure
  plot = ggplot(exons_df) + geom_blank()
  if(connect_exons){ #Print line connecting exons
    plot = plot + geom_line(aes_(x = ~start, y = ~transcript_rank, group = ~transcript_rank, color = ~feature_type))
  }
  plot = plot + 
    geom_rect(aes_(xmin = ~start, 
                   xmax = ~end, 
                   ymax = ~transcript_rank + 0.25, 
                   ymin = ~transcript_rank - 0.25, 
                   fill = ~feature_type)) + 
    theme_light() +
    theme(plot.margin=unit(c(0,1,1,1),"line"), 
          axis.title.y = element_blank(),
          axis.text.y = element_blank(),
          axis.ticks.y = element_blank(),
          legend.position="none",
          panel.grid.major = element_blank(),
          panel.grid.minor = element_blank(),
          strip.text.y = element_text(colour = "grey10"),
          strip.background = element_rect(fill = "grey85")) +
    xlab(xlabel) +
    facet_grid(type~.) +
    scale_y_continuous(expand = c(0.2,0.15)) +
    scale_fill_manual(values = c("#2c7bb6","#abd9e9")) + 
    scale_colour_manual(values = c("#2c7bb6","#abd9e9"))
  if(all(!is.na(limits))){
    plot = plot + scale_x_continuous(expand = c(0,0)) +
      coord_cartesian(xlim = limits)
  }
  if(transcript_label){
    plot = plot + geom_text(aes_(x = ~start, 
                                 y = ~transcript_rank + 0.30, 
                                 label = ~transcript_label), 
                            data = transcript_annot, hjust = 0, vjust = 0, size = 4)

  }
  return(plot)
}

makeCoveragePlot <- function(coverage_df, limits, alpha, fill_palette, coverage_type){
  #Plot coverage over a region
  coverage_plot = ggplot(coverage_df, aes_(~bins, ~coverage, group = ~sample_id, alpha = ~alpha)) + 
    geom_blank() +
    theme_light()
  #Choose between plotting a line and plotting area
  if(coverage_type == "line"){
    coverage_plot = coverage_plot + 
      geom_line(aes_(colour = ~colour_group), alpha = alpha, position = "identity") 
  } else if (coverage_type == "area"){
    coverage_plot = coverage_plot + 
      geom_area(aes_(fill = ~colour_group), alpha = alpha, position = "identity")
  } else if (coverage_type == "both"){
    coverage_plot = coverage_plot + 
      geom_area(aes_(fill = ~colour_group), alpha = alpha, position = "identity") +
      geom_line(aes_(colour = ~colour_group), alpha = alpha, position = "identity") 
  } else{
    stop("Coverage type not supported.")
  }
  coverage_plot = coverage_plot +
    facet_grid(track_id~.) +
    dataTrackTheme() + 
    scale_x_continuous(expand = c(0,0)) +
    scale_y_continuous(expand = c(0,0)) +
    coord_cartesian(xlim = limits) +
    scale_color_manual(values = fill_palette) +
    scale_fill_manual(values = fill_palette) +
    ylab("FPM")
  return(coverage_plot)
}

#' Make a Manahattan plot of p-values
#' 
#' The Manhattan plots is compatible with wiggpleplotr read coverage and transcript strucutre plots. 
#' Can be appended to those using the cowplot::plot_grid() function. 
#'
#' @param pvalues_df Data frame of association p-values (required columns: track_id, p_nominal, pos)
#' @param region_coords Start and end coordinates of the region to plot. 
#' @param color_R2 Color the points according to R2 from the lead variant. Require R2 column in the pvalues_df data frame.
#' @param data_track If TRUE, then remove all information from x-axis. 
#' Makes it easy to append to read coverage or transcript strcture plots using cowplot::plot_grid(). 
#'
#' @return gglot2 object
#' @examples
#' data = dplyr::data_frame(track_id = "GWAS", pos = sample(c(1:1000), 200), p_nominal = runif(200, min = 0.0000001, 1))
#' makeManhattanPlot(data, c(1,1000), data_track = FALSE)
#' @export
makeManhattanPlot <- function(pvalues_df, region_coords, color_R2 = FALSE, data_track = TRUE){
  
  #Make assertions
  assertthat::assert_that(assertthat::has_name(pvalues_df, "track_id"))
  assertthat::assert_that(assertthat::has_name(pvalues_df, "p_nominal"))
  assertthat::assert_that(assertthat::has_name(pvalues_df, "pos"))
  
  #If R2 is specified
  if(color_R2){
    assertthat::assert_that(assertthat::has_name(pvalues_df, "R2"))
    plot_base = ggplot(pvalues_df, aes_(x = ~pos, y = ~-log(p_nominal, 10), colour = ~R2)) + geom_blank()
  } else{
    #Else do not colour
    plot_base = ggplot(pvalues_df, aes_(x = ~pos, y = ~-log(p_nominal, 10))) + geom_blank()
  }
  
  #Make the rest of the plot
  plot = plot_base + 
    facet_grid(track_id ~ .) +
    geom_point() + 
    theme_light() + 
    ylab(expression(paste("-",log[10], " p-value"))) +
    scale_x_continuous(expand = c(0,0)) +
    coord_cartesian(xlim = region_coords)
  
  #Apply data track theme so that plots can later be pasted together with cowplot
  if(data_track){
    plot = plot + dataTrackTheme()
  }
  return(plot)
}
## end
#####################

```

## Create bigWig Files

```{r create_bigwig, echo=F, eval=TRUE, warning=FALSE, result=F, include = F}
pos <- grep("/nemo/stp", Obio@parameterList$AlignOutputEnsDir)

plotList <- list()
chnkVec <- as.vector(NULL, mode="character")
    

## Begin loop ##
print("Create BigWig")
for (i in 1:length(geneCoveragePlotVec)){
    print(geneCoveragePlotVec[i])
    chr <- unique(data[data$gene_name == geneCoveragePlotVec[i],"chromosome_name"])
    regionStart <- min(data[data$gene_name == geneCoveragePlotVec[i],"start_position"]) - 1000
    regionEnd   <- max(data[data$gene_name == geneCoveragePlotVec[i],"end_position"]) + 1000
    
    regionVar <- ""
    regionVar <- " -r chr8:78338395:80399518"
    regionVar <- paste0(" -r ",chr,":",regionStart,":",regionEnd)
    
    
    if (length(pos) == 0){
    Obio@parameterList$AlignOutputEnsDir <- paste0(
        workdir,
        "star_rsem/"
        )
    }
    
    bamFiles <- list.files(Obio@parameterList$AlignOutputEnsDir)
    bamFiles <- paste0(
        Obio@parameterList$AlignOutputEnsDir,
        bamFiles[grep("d.bam$", bamFiles)]
    )
    
    
    ## bam coverage can be limited to a chromosome or region with the --region flag
    # http://deeptools.readthedocs.io/en/develop/content/tools/bamCoverage.html#Optional%20arguments
    #Region of the genome to limit the operation to - this is useful when testing parameters to reduce the computing time. The format is chr:start:end, for example –region chr10 or –region chr10:456700:891000.
    
    cmdVec <- as.vector(NULL, mode="character")
    for (j in 1:length(bamFiles)){
        bwFN <- gsub(".bam", ".bw", bamFiles[j])
        newCmd <- paste0(
            'sbatch --time=02:00:00 --wrap "ml deepTools/3.5.5-foss-2022a; bamCoverage -b ',bamFiles[j],' -o ',bwFN, regionVar ,' --binSize 20 --normalizeUsing RPKM --smoothLength 60 --extendReads 150 --centerReads" --job-name=$project --mem=40G -o BW',j,'.slurm >> commands.txt'
        )
        
        cmdVec <- c(
            cmdVec, 
            newCmd
        )
    }
    
    FNsh <- paste0(
        Obio@parameterList$workdir,
        Obio@parameterList$project_id,
        ".bigWig.conversion.script.sh"
    )
    
    
    writeSH <- function(FNsh, cmdVec){
      sink(file=FNsh)
          cat("#! /bin/sh");cat("\n");cat("\n");
          cat("project=BWCV");cat("\n");cat("\n");
          
          for (j in 1:length(cmdVec)){
              cat(cmdVec[j]);cat("\n");cat("\n");
          }
      sink()
        
    }
    
    
    writeSH(FNsh = FNsh, cmdVec=cmdVec)
    
    ## Create bigwig files and wait for result ##
    ## This doesn't work from within a singularity container.
    system(paste0("sh ", FNsh))
    #stop("Run shell script to create bigWig files.")
    ## check if bwfn exists ##
    bwFNall <- gsub(".bam", ".bw", bamFiles)
    oldbwFiles <- bwFNall[file.exists(bwFNall)]
    
    if (length(oldbwFiles) > 0){
        unlink(oldbwFiles)
    }
    
    fileExists <- rep(F, length(bwFNall))
    while( sum( fileExists ) < length(bwFNall)){
        Sys.sleep(60)
        fileExists <- file.exists(bwFNall)
        print(paste0("Processing bigWig files: ", sum(fileExists), " out of ", length(bwFNall), " files processed."))
    }
    
    
    #############
    ## Do genomic plotting
    
    if (! is.null(Obio@parameterList$designTScol)){
        dfAnno <- unique(Obio@dfDesign[,c("sample.id", "sample.group", "sample.group_color", Obio@parameterList$designTScol)])
        dfAnno <- dfAnno[order(dfAnno[,Obio@parameterList$designTScol], decreasing = F),]
    } else {
      dfAnno <- unique(Obio@dfDesign[,c("sample.id", "sample.group", "sample.group_color")]) 
    }
    
    
    
    sampleVec <- unique(dfAnno$sample.id)
    sampleGroupVec <- dfAnno$sample.group
    sampleCols <- dfAnno$sample.group_color
    
    FNvec <- paste0(Obio@parameterList$AlignOutputEnsDir,sampleVec, ".markdup.sorted.bw")
    
    sizeFactors <- DESeq2::sizeFactors(Obio@ObjDds)
    sizeFactors <- sizeFactors[sampleVec]
    
    sample_data = dplyr::data_frame(
        sample_id = sampleVec, 
        condition = factor(sampleGroupVec, levels = unique(sampleGroupVec)), 
        scaling_factor = sizeFactors)
    
    library(dplyr)
    sample_data = sample_data %>%
        dplyr::mutate(bigWig = FNvec)

#as.data.frame(sample_data)





  

    selected_transcripts = transcript_metadata %>%
        dplyr::filter(gene_name == geneCoveragePlotVec[i])
    tx_ids = selected_transcripts$transcript_id
    gene_ids = selected_transcripts$gene_id
    # plotTranscripts(
    #     exons[tx_ids], cdss[tx_ids], 
    #     transcript_metadata, rescale_introns = TRUE)
    
    
    
    track_data = dplyr::mutate(sample_data, track_id = condition, colour_group = condition)
    
    #selected_transcripts = c("ENST00000438495", "ENST00000392477") #Plot only two transcripts of the gens
    
    
    tag <- paste0(geneCoveragePlotVec[i], "_Coverage")
    
    tx_ids_e <- tx_ids[tx_ids %in% names(exons)]
    
    
    tx_ids_c <- tx_ids[tx_ids %in% names(cdss)]
    
    if ((length(tx_ids_e) > 0) && (length(tx_ids_c) > 0)){
        # activate Cairo library

        plotList[[tag]] <- plotCoverage(
            exons = exons[tx_ids_e], 
            cdss = cdss[tx_ids_c], 
            transcript_metadata, 
            track_data,
            heights = c(2,1), 
            fill_palette = unique(sampleCols) ,
            rescale_introns = F,
            mean_only = FALSE, 
            alpha = 0.5,
            region_coords = c(regionStart, regionEnd)
        ) + theme(strip.text.y = element_text(size = 1)) # Change facet size on side
        
        
        FNbase <- paste0(tag, VersionPdfExt)
        FN <- paste0(Obio@parameterList$reportFigDir, FNbase)
        FNrel <- paste0("report_figures/", FNbase)
        
        pdf(FN)
            print(plotList[[tag]])
        dev.off()
        
        
        ## Create R markdown chunk ##
        figLegend <- paste0(
            "**Figure ",
            figureCount,
            ":** Gene Coverage Plot. ",
            "The gene coverage plot depicts the relative abundance of FPM values (fragments per million mapped fragments). The exon annotation underneath reflects the Ensembl annotation version used for the alignment of this RNA-Seq experiment. ",
                        "Download a pdf of this figure [here](", FNrel,"). "
        )
        
        
        figureCount <- figureCount + 1
        
        NewChnk <- paste0(
            "### ", tag,
            "\n```{r Gene_coverage", tag,
            ", results='asis', echo=F, eval=TRUE, warning=FALSE, fig.cap='",
            figLegend,"', fig.asp = 1, fig.align = 'center'}\n",
            "\n",
            "\n print(plotList[['",tag,"']])",
            "\n cat(  '\n')",
            "\n\n\n```\n"
        )
        
        
        chnkVec <- unique(c(
            chnkVec,
            NewChnk
        ))
        
        print(paste0(geneCoveragePlotVec[i], " done."))
    } else {
      print(paste0(geneCoveragePlotVec[i], " could not be processed."))
    }
}


if (length(plotList) > 3){
    tabVar <- ".tabset .tabset-fade .tabset-dropdown"
} else {
    tabVar <- ".tabset .tabset-fade .tabset-pills"
}

```

## Gene Coverage Plots {`r tabVar`}
The gene coverage plot depicts the relative abundance of FPM values (fragments per million mapped fragments). The exon annotation underneath reflects the Ensembl annotation version used for the alignment of this RNA-Seq experiment. 

```{r knit_cor_plot_characterization_plot, echo=TRUE, eval=TRUE, warning=FALSE, results="asis"}
cat(paste(knit(text = chnkVec, quiet = T), collapse = '\n'))
```

